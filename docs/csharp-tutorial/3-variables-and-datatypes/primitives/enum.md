---
noteId: "262625d0670f11f0ab62e3f747310bbc"
tags: []

---

## 枚举是什么

“枚举”（Enumeration）这个词来源于英文单词：

> **Enumeration（/ˌɛn.juː.məˈreɪ.ʃən/）** = 一一列举、枚举、列出

枚举（`enum`）是一种值类型，用于定义一组命名的常量集合，主要作用是用可读性强的符号替代无意义的数字（魔法数字），提升代码的可维护性。



## 为什么需要枚举？

用一句话概括：**枚举类型的作用就是用有意义的常量名字替代一组固定的数值，即提升了代码的可读性和可维护性，又不易出错（通过类型约束确保了取值的合法性）。**

原因:没有枚举可读性差难以维护

在实际工作中，面对一些常见的业务状态，比如用户账号的状态，在没有枚举之前，程序员通常会这样写代码：

```csharp
int status = 1; // 1 表示什么？没人知道！
if (status == 1)
{
    Console.WriteLine("正常");
}
else if (status == 2)
{
    Console.WriteLine("禁用");
}
```
- 这里的 `1` 和 `2` 就是所谓的**“魔法数字”（Magic Numbers），即：**没有明确的语义，就像被施了魔法一样，除了代码作者，没人知道他们的含义。
- 当别人接手你的代码时，根本不知道 `1` 是什么意思，只能看文档或者靠猜。
- 所以魔法数字带来的问题是：代码可读性差，难以维护，容易出错；

## 枚举的优势
### 明确语义可读性强
如果我们使用枚举重写，就会清晰很多：

```csharp
enum UserStatus
{
    Active,   // 0
    Disabled  // 1
}

UserStatus status = UserStatus.Active;
if (status == UserStatus.Active)
{
    Console.WriteLine("用户状态：正常");
}
```

- `UserStatus.Active` 比 `1` 更具可读性；
- 编译器知道这些是固定选项，能帮你避免传入非法值。

### 易于扩展和维护
现在，假设业务需求变了

产品经理或业务方说：

> “我们还需要一个中间状态，表示用户**提交了注册，但还未审核或激活**，这个状态叫 **Pending（待定 / 待激活）**。”

如果你使用的是枚举（enum），你只需要这样做：

```csharp
enum UserStatus
{
    Pending,   // 我们新增的状态，编译器默认值为 0
    Active,    // 变成了 1
    Disabled   // 变成了 2
}
```
**当你的业务逻辑需要新增一个状态（比如从原来的“激活/禁用”变成“待定/激活/禁用”），如果你使用的是枚举（enum），你只需要在枚举类型中简单地添加一个新成员（比如 `Pending,`），就可以很自然、很清晰、很安全地扩展这个状态，而不用改动大量已有代码，也不用担心值冲突或可读性问题。**

**就这么简单！你只需要在枚举中加一行：`Pending,`**
>
> - 枚举会**自动为其分配一个整数值（默认从 0 开始递增）**
> - 你可以在代码中直接使用 `UserStatus.Pending`，就像使用其它状态一样自然
> - 你的 `switch` 语句、状态判断、UI 显示等相关代码，都可以**很自然地扩展**

如果你没有使用枚举，而是用了“魔法数字”，会怎样？

假设你之前是这样写的：

```csharp
int status = 1; // 1 = 激活，2 = 禁用
if (status == 1) { /* 激活 */ }
else if (status == 2) { /* 禁用 */ }
```

现在要增加一个状态：**Pending（值为 0 或 3？）**

你可能会面临这些问题：

- 你该给 Pending 分配什么数字？0？3？怎么保证不冲突？
- 你代码中所有用到 `status == 1` 的地方，都要去查看这个 1 到底代表啥
- 你新增的状态可能忘记处理，导致逻辑遗漏或 Bug
- 其他程序员看不懂 0、1、2 是什么意思，可读性极差

---


## 定义枚举
枚举通过 `enum` 关键字声明，基本格式如下：
```csharp
[访问修饰符] enum 枚举名 [: 基础类型]
{
    成员1 [= 值],
    成员2 [= 值],
    ...
}
```

- **访问修饰符**：可选，如 `public`、`internal`（默认）、`private` 等，控制枚举的访问范围。
- enum：定义枚举类型的关键字；
- **枚举名**：遵循帕斯卡命名法（PascalCase），如 `OrderStatus`、`ErrorCode`。即首字母大写，后续每个单词的首字母也大写（如 Weekday、ErrorCode）。这是 Microsoft 官方推荐的编码规范，与类、结构等类型的命名规则一致，目的是通过名称直观区分类型与其他成员。
- **基础类型**：可选，必须是整数类型（`byte`、`sbyte`、`short`、`ushort`、`int`、`uint`、`long`、`ulong`），默认是 `int`。
- **枚举成员**：命名同样遵循帕斯卡命名法，每个成员本质是整数常量，可显式赋值或使用默认值。

成员值的规则

- **默认值**：若未显式赋值，第一个成员默认值为 `0`，后续成员依次递增 `1`。
- **显式赋值**：可手动指定成员值，未指定的成员会在前一个成员值的基础上递增 `1`。
- **允许重复值**：不同成员可赋予相同的值（但不推荐，可能导致混淆）。


- 每个枚举值必须关联一个整数值，称之为“基础值”。
- 基础值：必须是整数类型，默认从0开始，依次递增；
- 基础值与数组的“下标”非常类似，不同之处在于基础值可自定义，允许跳跃和重复。

| 特性        | 基础值                  | 数组下标                  |
|------------|---------------------------|--------------------------|
| **起始值**  | 可自定义(不一定是0)         | 固定从0开始               |
| **连续性**  | 可跳跃赋值(如100,200,300)  | 必须连续                  |
| **重复性**  | 允许多个成员同值           | 每个下标必须唯一          |
| **类型**    | 可指定多种整数类型          | 固定为int                |


## 枚举的基本操作

```c# linenums="1"
using System;

class Program
{
    // 1. 定义枚举：把一周的几天定义为枚举，就像给数字起名字
    enum Weekday
    {
        Monday,    // 对应数字0（默认从0开始）
        Tuesday,   // 对应数字1
        Wednesday, // 对应数字2
        Thursday,  // 对应数字3
        Friday,    // 对应数字4
        Saturday,  // 对应数字5
        Sunday     // 对应数字6
    }

    static void Main()
    {
        // 2. 访问枚举成员：直接用“枚举名.成员名”就能拿到定义好的成员
        Console.WriteLine("星期三是：" + Weekday.Wednesday);

        // 3. 赋值枚举成员（定义时完成）：上面定义时已经给每个成员分配了数字
        // 比如Monday=0，Tuesday=1，这里不需要额外操作

        // 4. 在声明一个枚举类型后，可定义该枚举类型的变量，简称枚举变量。
        // 声明枚举变量：声明一个能存储星期几的变量
        Weekday today;

        // 5. 为枚举变量赋值：给变量指定具体的星期
        today = Weekday.Friday;

        // 6. 访问枚举变量：使用这个变量，查看它存储的星期
        Console.WriteLine("今天是：" + today);

        // 7.查看枚举成员对应的数字（需要强制转换）
        Console.WriteLine("星期五对应的数字是：" + (int)today);
    }
}
```
