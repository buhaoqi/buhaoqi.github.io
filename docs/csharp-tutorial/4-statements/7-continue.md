---
noteId: "80a0a650797211f096197f4ef3b2c3fb"
tags: []

---

在 C# 中，`continue` 是一个**控制流语句（control flow statement）**，用于**跳过当前循环迭代中剩余的代码，并直接进入该循环的下一次迭代**。它**不会终止整个循环**，只是**跳过本轮循环中 `continue` 之后的代码**，然后继续执行下一次循环（如果有的话）。

---

## 一、`continue` 的基本概念

| 特性 | 说明 |
|------|------|
| **作用** | 跳过当前循环的剩余部分，直接进入下一次循环迭代 |
| **适用场景** | 仅用于 **循环结构**：`for`、`while`、`do...while`、`foreach` |
| **不终止循环** | 与 `break` 不同，`continue` 不会终止整个循环，只是跳过当前这一次 |
| **不影响外层循环** | 在嵌套循环中，`continue` 只影响它所在的那一层循环 |

---

## 二、`continue` 的常见使用场景

### ✅ 1. 在 `for` 循环中使用 `continue`

当在 `for` 循环中遇到 `continue;` 时，**当前迭代中 `continue` 之后的代码会被跳过，直接进入下一次循环（即 i++ 并判断条件）**。

#### 示例：跳过偶数，只打印奇数

```csharp
for (int i = 1; i <= 5; i++)
{
    if (i % 2 == 0) // 如果是偶数
    {
        continue; // 跳过当前迭代
    }
    Console.WriteLine(i); // 只打印奇数
}
// 输出：1 3 5
```

**执行过程简述：**

- i = 1 → 不是偶数 → 打印 1
- i = 2 → 是偶数 → 执行 `continue` → 跳过打印，进入 i=3
- i = 3 → 不是偶数 → 打印 3
- i = 4 → 是偶数 → 执行 `continue` → 跳过
- i = 5 → 不是偶数 → 打印 5

---

### ✅ 2. 在 `while` 循环中使用 `continue`

在 `while` 循环中，`continue;` 会跳过当前循环体中剩余的代码，并**直接回到循环条件判断处**（即重新判断 `while` 条件是否成立）。

#### 示例：打印 1 到 5，但跳过数字 3

```csharp
int i = 1;
while (i <= 5)
{
    if (i == 3)
    {
        i++; // ⚠️注意：一定要记得递增，否则可能造成死循环！
        continue;
    }
    Console.WriteLine(i);
    i++;
}
// 输出：1 2 4 5
```

> ⚠️ **重要提示：** 在 `while` 循环中使用 `continue` 时，如果你在 `continue` 之前没有更新循环变量（比如 `i++`），就可能导致**死循环**，因为循环条件可能永远为 true，而 `continue` 又会跳过更新语句。

---

### ✅ 3. 在 `do...while` 循环中使用 `continue`

与 `while` 类似，但在 `do...while` 中是**先执行循环体，再判断条件**。`continue;` 会跳过当前迭代剩余代码，并重新进行条件判断。

#### 示例：跳过某个特定值

```csharp
int x = 0;
do
{
    x++;
    if (x == 3)
    {
        continue; // 跳过打印 3
    }
    Console.WriteLine(x);
}
while (x < 5);
// 输出：1 2 4 5
```

---

### ✅ 4. 在 `foreach` 循环中使用 `continue`

在遍历集合（比如数组、列表等）时，如果想跳过某些元素，可以使用 `continue`。

#### 示例：遍历数组，跳过数字 2

```csharp
int[] numbers = { 1, 2, 3, 4, 2, 5 };
foreach (int num in numbers)
{
    if (num == 2)
    {
        continue; // 跳过数字 2
    }
    Console.WriteLine(num);
}
// 输出：1 3 4 5
```

---

## 三、`continue` vs `break`

为了更好地理解 `continue`，我们将其与经常一起出现的 `break` 进行对比：

| 语句     | 作用对象       | 行为                                                         | 是否终止循环 |
|----------|----------------|--------------------------------------------------------------|--------------|
| `break`  | 循环 / switch  | **立即终止整个循环或 switch 语句的执行**                     | ✅ 是        |
| `continue` | **仅循环**     | **跳过当前迭代中剩余的代码，直接进入下一次循环的开始**       | ❌ 否        |

🔍 **简单记忆：**
- `break` → **“停下来，不干了”**（终止整个循环）
- `continue` → **“跳过这次，继续下一次”**（仅跳过当前这轮）

---

## 四、嵌套循环中的 `continue`

当存在**嵌套循环（循环中还有循环）**时，`continue` **只影响它所在的那一层循环**，不会影响外层或内层的其它循环。

#### 示例：嵌套 for 循环中的 continue

```csharp
for (int i = 1; i <= 3; i++)
{
    Console.WriteLine($"外层循环 i = {i}");
    for (int j = 1; j <= 3; j++)
    {
        if (j == 2)
        {
            continue; // 只跳过当前内层循环的 j=2 的情况
        }
        Console.WriteLine($"  内层循环 j = {j}");
    }
}
```

**输出结果：**
```
外层循环 i = 1
  内层循环 j = 1
  内层循环 j = 3
外层循环 i = 2
  内层循环 j = 1
  内层循环 j = 3
外层循环 i = 3
  内层循环 j = 1
  内层循环 j = 3
```

说明：当内层 `j == 2` 时，执行了 `continue;`，跳过了 `Console.WriteLine($"  内层循环 j = {j}");`，但内层循环仍会继续执行 `j++` 并进入下一次迭代（比如 j=3）。

---

## 五、实际应用场景举例

### ✅ 场景 1：筛选或过滤数据

遍历一个集合，只处理满足某些条件的元素，不满足的直接跳过。

```csharp
List<int> values = new List<int> { 10, 0, 20, 0, 30 };

foreach (int val in values)
{
    if (val == 0)
    {
        continue; // 跳过 0，不执行除法等危险操作
    }
    Console.WriteLine(100 / val); // 比如做一些计算，避免除以 0
}
// 输出：10 5 3.333...（实际是整数除法或浮点结果）
```

---

### ✅ 场景 2：处理特定条件时跳过

比如在读取文件、处理用户输入或者遍历数据时，遇到某些特殊情况（如空值、无效数据）希望跳过当前项。

---

## 六、总结

| 项目 | 说明 |
|------|------|
| **`continue` 的作用** | 跳过当前循环的剩余代码，直接开始下一次循环迭代 |
| **适用循环类型** | `for`、`while`、`do...while`、`foreach` |
| **不支持的上下文** | 不能在 `if`、方法、类等非循环结构中使用，否则编译报错 |
| **与 `break` 的区别** | `continue` 只跳过当前迭代，`break` 终止整个循环 |
| **在嵌套循环中的影响范围** | 只影响所在的那层循环，不会影响外层或内层其他循环 |
| **注意事项** | 在 `while` 和 `do...while` 中使用 `continue` 时，要确保循环变量能正确更新，避免死循环 |

---

## 七、最佳实践建议

- **合理使用 `continue`** 来提高代码可读性，尤其是在需要过滤某些情况时，可以避免过多的嵌套 `if`。
- **避免在 `while` 循环中使用 `continue` 而忘记更新循环变量**，这样容易导致死循环。
- **优先考虑代码清晰性**：有时候用 `if (!条件)` 包裹代码块，比 `if (条件) { continue; }` 更易于理解，尤其是在复杂逻辑中。

---

如果你有更具体的使用场景，比如在 `foreach` 中跳过某些对象、或在嵌套循环中控制流程，欢迎继续提问！我可以为你提供更定制化的示例。