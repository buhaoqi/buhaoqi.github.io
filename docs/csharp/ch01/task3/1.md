---
# 这部分是关键！侧边栏显示名由这里决定
title: 任务三 算法的时间复杂度  # 文档标题，若无 sidebar_label 则作为侧边栏名
sidebar_label: 任务三 算法的时间复杂度  # 显式指定侧边栏显示名（优先级最高）
sidebar_position: 1  # 侧边栏中排在第1位
---

任务三 算法分析与评价

# 算法时间复杂度：一听就懂的解释

## 一、先别怕，我们换个角度理解

想象你要整理一堆书：

1. **O(1)** - 找到第一本书（不管有多少书，都是拿第一本）
2. **O(n)** - 检查每本书的封面（书越多，时间越长）
3. **O(log n)** - 按字母顺序找一本书（每次都扔掉一半不找）
4. **O(n²)** - 每本书都和其他所有书比较
5. **O(2ⁿ)** - 书的所有可能排列组合

## 二、用C#代码直观感受

### 1. O(1) - 常数时间（最快）
```csharp
// 无论数组多大，时间都一样
int GetFirstElement(int[] array)
{
    return array[0];  // 直接访问第一个元素
    // 时间复杂度：O(1)
}

// 另一个例子：
bool IsEven(int number)
{
    return number % 2 == 0;  // 一次计算
    // 时间复杂度：O(1)
}
```
**特点**：不随数据量变化，速度最快

---

### 2. O(n) - 线性时间（很常见）
```csharp
// 搜索数组中的某个值
bool FindValue(int[] array, int target)
{
    for (int i = 0; i < array.Length; i++)  // 循环n次
    {
        if (array[i] == target)
            return true;
    }
    return false;
    // 时间复杂度：O(n)
}

// 计算数组总和
int SumArray(int[] array)
{
    int sum = 0;
    foreach (int num in array)  // 遍历每个元素
    {
        sum += num;
    }
    return sum;
    // 时间复杂度：O(n)
}
```
**特点**：数据翻倍，时间也翻倍

---

### 3. O(log n) - 对数时间（很高效）
```csharp
// 二分查找（要求数组已排序）
int BinarySearch(int[] array, int target)
{
    int left = 0;
    int right = array.Length - 1;
    
    while (left <= right)  // 每次减少一半范围
    {
        int mid = (left + right) / 2;
        
        if (array[mid] == target)
            return mid;              // 找到了
        else if (array[mid] < target)
            left = mid + 1;          // 去右边找
        else
            right = mid - 1;         // 去左边找
    }
    return -1;  // 没找到
    // 时间复杂度：O(log n)
}
```
**例子**：1000本书，最多找10次；100万本书，最多找20次

---

### 4. O(n²) - 平方时间（开始慢了）
```csharp
// 冒泡排序
void BubbleSort(int[] array)
{
    for (int i = 0; i < array.Length - 1; i++)      // 外层循环
    {
        for (int j = 0; j < array.Length - i - 1; j++)  // 内层循环
        {
            if (array[j] > array[j + 1])
            {
                // 交换
                int temp = array[j];
                array[j] = array[j + 1];
                array[j + 1] = temp;
            }
        }
    }
    // 时间复杂度：O(n²)
}

// 打印所有两两组合
void PrintAllPairs(string[] names)
{
    for (int i = 0; i < names.Length; i++)      // n次
    {
        for (int j = 0; j < names.Length; j++)  // n次
        {
            Console.WriteLine($"{names[i]} - {names[j]}");
        }
    }
    // 时间复杂度：O(n²)
}
```
**特点**：100个数据需要1万次操作，1千个数据需要100万次操作

---

### 5. O(2ⁿ) - 指数时间（非常慢）
```csharp
// 斐波那契数列（低效版本）
int Fibonacci(int n)
{
    if (n <= 1) 
        return n;
        
    return Fibonacci(n - 1) + Fibonacci(n - 2);
    // 时间复杂度：O(2ⁿ) - 呈指数增长
}

// 优化后的版本（O(n)）
int FibonacciFast(int n)
{
    if (n <= 1) 
        return n;
        
    int[] fib = new int[n + 1];
    fib[0] = 0;
    fib[1] = 1;
    
    for (int i = 2; i <= n; i++)
    {
        fib[i] = fib[i - 1] + fib[i - 2];
    }
    
    return fib[n];
    // 时间复杂度：O(n)
}
```
**警告**：n=40时，低效版本需要1万亿次操作！

---

## 三、时间复杂度对比图

```
数据量(n)    O(1)    O(log n)    O(n)    O(n²)     O(2ⁿ)
--------------------------------------------------------
10          1        ~4          10      100       1024
100         1        ~7          100     10,000    1.26e30
1000        1        ~10         1000    1,000,000 巨大！
10000       1        ~13         10000   100,000,000 天文数字
```

**直观感受**：
- O(1)：瞬间完成
- O(log n)：稍微等一下
- O(n)：等一会儿
- O(n²)：等很久
- O(2ⁿ)：等到天荒地老

---

## 四、实际代码对比

```csharp
using System;
using System.Diagnostics;

class TimeComplexityDemo
{
    static void Main()
    {
        int[] smallArray = new int[100];
        int[] mediumArray = new int[1000];
        int[] largeArray = new int[10000];
        
        // 初始化数组
        Random rand = new Random();
        for (int i = 0; i < largeArray.Length; i++)
        {
            if (i < smallArray.Length) smallArray[i] = rand.Next();
            if (i < mediumArray.Length) mediumArray[i] = rand.Next();
            largeArray[i] = rand.Next();
        }
        
        Console.WriteLine("不同时间复杂度算法对比\n");
        
        // 测试O(1)
        TestAlgorithm("O(1) - 取第一个元素", () => GetFirstElement(largeArray));
        
        // 测试O(n)  
        TestAlgorithm("O(n) - 求数组和 (小)", () => SumArray(smallArray));
        TestAlgorithm("O(n) - 求数组和 (中)", () => SumArray(mediumArray));
        TestAlgorithm("O(n) - 求数组和 (大)", () => SumArray(largeArray));
        
        // 测试O(n²)
        Console.WriteLine("警告：O(n²)算法较慢，是否继续测试？(y/n)");
        if (Console.ReadLine()?.ToLower() == "y")
        {
            TestAlgorithm("O(n²) - 冒泡排序 (小)", () => BubbleSort(smallArray));
            // 中大型数组的O(n²)可能非常慢！
        }
        
        Console.WriteLine("\n关键点：");
        Console.WriteLine("1. O(1)最快，与数据量无关");
        Console.WriteLine("2. O(n)随数据量线性增长");
        Console.WriteLine("3. O(n²)小数据还行，大数据很慢");
        Console.WriteLine("4. 实际开发要避免O(n²)和更慢的算法");
    }
    
    static void TestAlgorithm(string name, Action algorithm)
    {
        var stopwatch = Stopwatch.StartNew();
        algorithm();
        stopwatch.Stop();
        Console.WriteLine($"{name}: {stopwatch.ElapsedMilliseconds}ms");
    }
}
```

---

## 五、如何快速判断时间复杂度？

### 看循环结构：

```csharp
// O(1) - 没有循环或固定循环
for (int i = 0; i < 10; i++) { }  // 固定10次，O(1)

// O(n) - 单层循环
for (int i = 0; i < n; i++) { }   // 循环n次，O(n)

// O(n²) - 嵌套循环
for (int i = 0; i < n; i++)       // 外层n次
{
    for (int j = 0; j < n; j++)   // 内层n次
    {
        // O(n²)
    }
}

// O(log n) - 每次减半
int n = 100;
while (n > 0)                     // 循环log₂n次
{
    n = n / 2;                    // 每次减半
    // O(log n)
}
```

### 实战判断练习：
```csharp
// 这个算法的时间复杂度是多少？
void MysteryAlgorithm(int[] array)
{
    // 第一部分：O(n)
    for (int i = 0; i < array.Length; i++)
    {
        Console.WriteLine(array[i]);
    }
    
    // 第二部分：O(n²)  
    for (int i = 0; i < array.Length; i++)
    {
        for (int j = 0; j < array.Length; j++)
        {
            Console.WriteLine($"{array[i]} + {array[j]}");
        }
    }
    
    // 总时间复杂度：O(n) + O(n²) = O(n²)
    // 取最大的那个！
}
```

---

## 六、为什么学习时间复杂度？

### 真实案例：

```csharp
// 案例1：处理用户数据
// 有1000用户 vs 100万用户

// 糟糕的O(n²)算法
void ProcessUsersBad(User[] users)
{
    foreach (var user1 in users)          // n次
    {
        foreach (var user2 in users)      // n次
        {
            CompareUsers(user1, user2);   // 总共n²次
        }
    }
    // 1000用户：100万次比较
    // 100万用户：1万亿次比较！❌
}

// 好的O(n log n)算法  
void ProcessUsersGood(User[] users)
{
    Array.Sort(users);                    // O(n log n)
    
    foreach (var user in users)           // O(n)
    {
        // 处理每个用户
    }
    // 总：O(n log n)
    // 100万用户：约2000万次操作 ✅
}
```

### 关键收获：
1. **选择比努力重要**：好算法比快计算机更重要
2. **预判问题**：知道算法能不能处理大数据
3. **写出高效代码**：避免让程序卡死
4. **面试必备**：大公司必考知识点

---

## 七、一句话总结

**时间复杂度就是：你的算法在数据变多时，会慢多少倍。**

- **O(1)**：数据再多也一样快 ✅
- **O(log n)**：数据翻倍，只慢一点 ✅
- **O(n)**：数据翻倍，时间翻倍 ⚠️
- **O(n²)**：数据翻倍，时间变4倍 ❌
- **O(2ⁿ)**：多几个数据，等到宇宙毁灭 ❌❌

**记住**：写代码时想想，如果数据量×1000，你的算法还能用吗？