---
# 这部分是关键！侧边栏显示名由这里决定
title: 任务二 算法设计  # 文档标题，若无 sidebar_label 则作为侧边栏名
sidebar_label: 任务二 算法设计  # 显式指定侧边栏显示名（优先级最高）
sidebar_position: 3  # 侧边栏中排在第1位
---


# 算法设计的要求

算法设计四大要求深度解读

## 一、正确性（Correctness）- "算法必须是对的"

### 什么是正确性？
**算法对所有合法输入都能产生正确结果**

### 正确性等级：
1. **基本正确**：对一般数据能工作
2. **边界正确**：对极端数据也能工作  
3. **完全正确**：对所有可能数据都能工作

### C#示例对比：

**错误示例**（缺乏正确性）：
```csharp
// 问题：计算1到n的和，但n为0或负数时出错
public static int Sum(int n)
{
    int sum = 0;
    for (int i = 1; i <= n; i++)  // n=0时循环不会执行，但n=-1时会无限循环？
    {
        sum += i;
    }
    return sum;
}
```

**正确示例**（考虑各种情况）：
```csharp
public static int Sum(int n)
{
    if (n < 0)
    {
        throw new ArgumentException("n不能为负数"); // 明确处理非法输入
    }
    
    // 方法1：循环实现
    int sum = 0;
    for (int i = 1; i <= n; i++)
    {
        sum += i;
    }
    return sum;
    
    // 或者方法2：数学公式实现
    // return n * (n + 1) / 2;
}
```

### 测试正确性的要点：
```csharp
[Test]
public void TestSumCorrectness()
{
    // 1. 正常情况测试
    Assert.AreEqual(55, Sum(10));    // 1+2+...+10=55
    
    // 2. 边界情况测试
    Assert.AreEqual(0, Sum(0));      // 空序列和为0
    Assert.AreEqual(1, Sum(1));      // 最小正整数
    
    // 3. 大数情况测试（防止溢出）
    Assert.AreEqual(50005000, Sum(10000));
    
    // 4. 非法输入测试
    Assert.Throws<ArgumentException>(() => Sum(-1));
}
```

---

## 二、可读性（Readability）- "代码要像文章一样易读"

### 为什么可读性重要？
- **团队协作**：别人能看懂你的代码
- **维护性**：6个月后你自己还能看懂
- **减少错误**：清晰逻辑减少隐藏bug

### C#示例对比：

**低可读性示例**：
```csharp
public int f(int n)
{
    int s = 0;
    for (int i = 1; i <= n; i++) s += i;
    return s;
}
// 问题：变量名无意义，没有注释，一行完成太多操作
```

**高可读性示例**：
```csharp
/// <summary>
/// 计算从1到指定数字的累加和
/// </summary>
/// <param name="upperBound">累加的上限（必须为非负整数）</param>
/// <returns>从1到upperBound的整数和</returns>
public static int CalculateSumUpTo(int upperBound)
{
    // 输入验证
    if (upperBound < 0)
    {
        throw new ArgumentOutOfRangeException(nameof(upperBound), "上限值不能为负数");
    }
    
    int totalSum = 0;
    
    // 累加从1到上限值的所有整数
    for (int currentNumber = 1; currentNumber <= upperBound; currentNumber++)
    {
        totalSum += currentNumber;
    }
    
    return totalSum;
}
```

### 提高可读性的技巧：
```csharp
// 技巧1：有意义的命名
DateTime orderDate;          // √ 好
DateTime d;                  // × 差

// 技巧2：适当的空格和换行
if (age >= 18 && score > 60) // √ 易读
if(age>=18&&score>60)        // × 难读

// 技巧3：使用常量代替魔法数字
const int AdultAge = 18;
const int PassingScore = 60;

// 技巧4：方法职责单一
public void ProcessOrder(Order order)
{
    ValidateOrder(order);     // 验证订单
    CalculateTotal(order);    // 计算总额
    SaveToDatabase(order);    // 保存数据
    SendConfirmation(order);  // 发送确认
}
```

---

## 三、健壮性（Robustness）- "打不死的算法"

### 什么是健壮性？
**算法能优雅地处理异常和错误情况**

### C#健壮性示例：

```csharp
public class BankAccount
{
    private decimal balance;
    
    // 不健壮的取款方法
    public void WithdrawUnsafe(decimal amount)
    {
        balance -= amount;  // 如果amount为负数？如果余额不足？
    }
    
    // 健壮的取款方法
    public bool WithdrawRobust(decimal amount)
    {
        // 1. 参数验证
        if (amount <= 0)
        {
            Console.WriteLine("取款金额必须为正数");
            return false;
        }
        
        if (amount > 10000)  // 业务限制
        {
            Console.WriteLine("单次取款不能超过10000元");
            return false;
        }
        
        // 2. 状态检查
        if (balance < amount)
        {
            Console.WriteLine($"余额不足，当前余额：{balance:C}");
            return false;
        }
        
        // 3. 执行操作
        try
        {
            balance -= amount;
            Console.WriteLine($"成功取款 {amount:C}，剩余余额：{balance:C}");
            return true;
        }
        catch (Exception ex)
        {
            // 4. 异常处理
            Console.WriteLine($"取款失败：{ex.Message}");
            return false;
        }
    }
}
```

### 常见错误处理模式：

```csharp
public class RobustAlgorithm
{
    // 模式1：返回值表示状态
    public (bool success, int result, string error) SafeDivide(int a, int b)
    {
        if (b == 0)
        {
            return (false, 0, "除数不能为零");
        }
        
        return (true, a / b, string.Empty);
    }
    
    // 模式2：异常处理
    public int DivideWithException(int a, int b)
    {
        if (b == 0)
        {
            throw new ArgumentException("除数不能为零", nameof(b));
        }
        
        return a / b;
    }
    
    // 模式3：默认值处理
    public int ParseIntOrDefault(string input, int defaultValue = 0)
    {
        if (int.TryParse(input, out int result))
        {
            return result;
        }
        
        Console.WriteLine($"无法解析 '{input}'，使用默认值 {defaultValue}");
        return defaultValue;
    }
}
```

---

## 四、高效率与低存储量 - "又快又省"

### 效率（时间复杂度）对比：

```csharp
public class EfficiencyExamples
{
    // 方法1：O(n) 时间复杂度 - 线性
    public static int FindMaxLinear(int[] numbers)
    {
        if (numbers == null || numbers.Length == 0)
            throw new ArgumentException("数组不能为空");
            
        int max = numbers[0];
        foreach (int num in numbers)  // 遍历一次：O(n)
        {
            if (num > max)
                max = num;
        }
        return max;
    }
    
    // 方法2：O(n²) 时间复杂度 - 平方级（低效）
    public static int FindMaxInefficient(int[] numbers)
    {
        int max = int.MinValue;
        for (int i = 0; i < numbers.Length; i++)        // 外层循环
        {
            for (int j = 0; j < numbers.Length; j++)    // 内层循环
            {
                if (numbers[i] > max)                   // 不必要的重复比较
                    max = numbers[i];
            }
        }
        return max;
    }
}
```

### 存储量（空间复杂度）对比：

```csharp
public class MemoryUsageExamples
{
    // 低存储量方法：O(1) 空间复杂度
    public static void ProcessArrayInPlace(int[] array)
    {
        // 原地操作，不需要额外数组
        for (int i = 0; i < array.Length; i++)
        {
            array[i] *= 2;  // 直接在原数组上修改
        }
    }
    
    // 高存储量方法：O(n) 空间复杂度
    public static int[] ProcessArrayWithCopy(int[] array)
    {
        // 创建新数组，需要额外空间
        int[] result = new int[array.Length];  // 额外占用内存
        for (int i = 0; i < array.Length; i++)
        {
            result[i] = array[i] * 2;
        }
        return result;
    }
}
```

### 效率优化的实际案例：

```csharp
// 案例：查找数组中有无重复元素

// 方法1：暴力法 O(n²)，但空间复杂度低
public static bool HasDuplicatesSlow(int[] nums)
{
    for (int i = 0; i < nums.Length; i++)
    {
        for (int j = i + 1; j < nums.Length; j++)
        {
            if (nums[i] == nums[j])
                return true;
        }
    }
    return false;
}

// 方法2：哈希表法 O(n)，但需要额外空间
public static bool HasDuplicatesFast(int[] nums)
{
    HashSet<int> seen = new HashSet<int>();  // 额外空间 O(n)
    
    foreach (int num in nums)                // 只需遍历一次 O(n)
    {
        if (seen.Contains(num))
            return true;
        seen.Add(num);
    }
    return false;
}

// 方法3：排序法 O(n log n)，折中方案
public static bool HasDuplicatesMedium(int[] nums)
{
    Array.Sort(nums);  // O(n log n) 时间复杂度
    
    for (int i = 1; i < nums.Length; i++)  // O(n)
    {
        if (nums[i] == nums[i - 1])
            return true;
    }
    return false;
}
```

---

## 四要素平衡的实际应用

### 综合示例：用户登录验证算法

```csharp
public class LoginService
{
    // 平衡四大要求的设计
    public LoginResult Authenticate(string username, string password)
    {
        // 1. 健壮性：输入验证
        if (string.IsNullOrWhiteSpace(username) || 
            string.IsNullOrWhiteSpace(password))
        {
            return LoginResult.CreateFailed("用户名和密码不能为空");
        }
        
        if (username.Length > 50 || password.Length > 100)
        {
            return LoginResult.CreateFailed("输入长度超出限制");
        }
        
        // 2. 正确性：业务逻辑
        User user = FindUserByUsername(username);
        
        if (user == null)
        {
            // 安全性考虑：不明确提示"用户不存在"
            return LoginResult.CreateFailed("用户名或密码错误");
        }
        
        // 3. 效率：使用哈希验证，避免明文比较
        bool passwordValid = VerifyPasswordHash(password, user.PasswordHash);
        
        if (!passwordValid)
        {
            UpdateFailedAttempts(user);  // 记录失败尝试
            return LoginResult.CreateFailed("用户名或密码错误");
        }
        
        // 4. 可读性：清晰的业务流程
        if (user.IsLocked)
        {
            return LoginResult.CreateFailed("账户已被锁定，请联系管理员");
        }
        
        if (user.MustChangePassword)
        {
            return LoginResult.CreateSuccessWithAction("登录成功，请修改密码", 
                                                       UserAction.ChangePassword);
        }
        
        ResetFailedAttempts(user);  // 重置失败计数
        return LoginResult.CreateSuccess("登录成功");
    }
    
    // 私有方法：提高可读性
    private User FindUserByUsername(string username)
    {
        // 使用索引提高查询效率
        return _userRepository.GetByUsername(username.ToLower());
    }
    
    private bool VerifyPasswordHash(string input, string storedHash)
    {
        // 使用恒定时间比较，防止时序攻击
        return CryptographicOperations.FixedTimeEquals(
            Encoding.UTF8.GetBytes(ComputeHash(input)),
            Encoding.UTF8.GetBytes(storedHash));
    }
}
```

---

## 实际开发建议

### 1. **正确性第一**
```csharp
// 编写前先明确需求
// 设计时考虑边界情况
// 实现后充分测试
```

### 2. **可读性就是生产力**
```csharp
// 写给人看的代码，顺便给机器执行
// 好代码是最好的文档
// 一个方法只做一件事
```

### 3. **健壮性不是可选项**
```csharp
// 假设所有输入都可能出错
// 优雅地处理异常
// 提供有用的错误信息
```

### 4. **效率需要权衡**
```csharp
// 先写正确的代码，再考虑优化
// 80%的时间消耗在20%的代码上
// 不要过早优化
```

## 一句话总结：
**好算法 = 正确的结果 + 清晰的逻辑 + 健壮的处理 + 合理的效率**

