---
# 这部分是关键！侧边栏显示名由这里决定
title: 五、字符串加密算法 # 文档标题，若无 sidebar_label 则作为侧边栏名
sidebar_label: 五、字符串加密算法  # 显式指定侧边栏显示名（优先级最高）
sidebar_position: 2  # 侧边栏中排在第1位
---

## 高考考点

> 字符串的加密算法

## 一、 字符串加密算法的工作原理
字符串加密的核心考点是「**基于字符ASCII码的简单变换**」，所有算法都围绕「字符→ASCII码→变换处理→还原字符」的流程展开，重点掌握以下3种基础算法。


## 二、凯撒密码（移位加密）
### 1.  算法简介
凯撒密码是最基础的「移位加密算法」，核心是将字符串中的每个字母按照固定步长（偏移量）在字母表中移动，得到加密后的字符。
- 例如：偏移量=3，字母`a`→`d`、`b`→`e`、`Z`→`C`（循环移位）
- 特点：原理简单、手动计算容易、加密/解密可逆（偏移量相反即可解密）

### 2.  核心原理
1.  明确「ASCII码对应关系」（中职必须熟记）：
    - 大写字母 `A-Z`：对应 ASCII 码 `65-90`
    - 小写字母 `a-z`：对应 ASCII 码 `97-122`
2.  加密步骤（以偏移量`key=3`为例）：
    - 遍历字符串中的每个字符；
    - 若是大写字母：`(字符ASCII码 - 65 + key) % 26 + 65`（`%26`实现循环移位，如`Z(90)`→`(90-65+3)%26+65=67`→`C`）；
    - 若是小写字母：`(字符ASCII码 - 97 + key) % 26 + 97`；
    - 若是数字/符号（可选）：直接保留，或按类似逻辑移位（如数字`0-9`对应`48-57`）；
3.  解密步骤：加密的逆过程，偏移量取`-key`即可（如`key=-3`）。

### 3.  手动加密示例
**题目**：将字符串`"abcXYZ"`以偏移量`key=3`进行凯撒加密。
- 步骤拆解：
  1.  `a(97)` → `(97-97+3)%26+97=100` → `d`
  2.  `b(98)` → `(98-97+3)%26+97=101` → `e`
  3.  `c(99)` → `(99-97+3)%26+97=102` → `f`
  4.  `X(88)` → `(88-65+3)%26+65=91%26=17+65=82` → `A`
  5.  `Y(89)` → `(89-65+3)%26+65=83` → `B`
  6.  `Z(90)` → `(90-65+3)%26+65=84` → `C`
- 加密结果：`"defABC"`

### 4.  C#代码实现
```csharp
using System;

class CaesarCipher
{
    static void Main(string[] args)
    {
        // 待加密字符串
        string originalStr = "abcXYZ";
        // 偏移量
        int key = 3;

        // 加密
        string encryptedStr = CaesarEncrypt(originalStr, key);
        Console.WriteLine($"加密前：{originalStr}");
        Console.WriteLine($"加密后：{encryptedStr}");

        // 解密（偏移量取反）
        string decryptedStr = CaesarEncrypt(encryptedStr, -key);
        Console.WriteLine($"解密后：{decryptedStr}");
    }

    static string CaesarEncrypt(string str, int key)
    {
        // 存储结果（中职常用StringBuilder，这里用string拼接更易理解）
        string result = "";

        // 遍历每个字符
        foreach (char c in str)
        {
            // 处理大写字母
            if (c >= 'A' && c <= 'Z')
            {
                // 核心公式：循环移位
                char encryptedChar = (char)((c - 'A' + key) % 26 + 'A');
                // 处理偏移量为负数的情况（解密时），避免出现非字母
                if (encryptedChar < 'A')
                {
                    encryptedChar += (char)26;
                }
                result += encryptedChar;
            }
            // 处理小写字母
            else if (c >= 'a' && c <= 'z')
            {
                char encryptedChar = (char)((c - 'a' + key) % 26 + 'a');
                if (encryptedChar < 'a')
                {
                    encryptedChar += (char)26;
                }
                result += encryptedChar;
            }
            // 非字母字符（数字、符号、空格）直接保留
            else
            {
                result += c;
            }
        }

        return result;
    }
}
```

### 运行结果
```
加密前：abcXYZ
加密后：defABC
解密后：abcXYZ
```

---

## 算法2： 简单替换密码（固定映射加密）
### 1.  算法简介
简单替换密码是「一对一字符映射」加密，核心是预先定义一个「明文→密文」的映射表（如`A→Z`、`B→Y`、`a→z`），加密时直接将字符串中的字符按映射表替换，解密时使用反向映射表即可。
- 特点：逻辑极其简单，无需计算，适合中职学生入门，笔试常考「根据映射表手动加密」。

### 2.  核心原理
1.  定义映射表（两种方式，中职常用第一种）：
    - 方式1：对称替换（如字母表倒序：`A↔Z`、`B↔Y`、`a↔z`）；
    - 方式2：自定义映射（如`A→3`、`B→5`、`a→#`，需牢记映射关系）；
2.  加密步骤：遍历字符串，逐个字符按映射表替换，无映射的字符直接保留；
3.  解密步骤：使用反向映射表（如加密时`A→Z`，解密时`Z→A`）。

### 3.  手动加密示例
**题目**：根据「英文字母倒序映射」，加密字符串`"Abc123"`。
- 映射表：`A↔Z`、`B↔Y`、`C↔X`...`a↔z`、`b↔y`、`c↔x`
- 步骤拆解：
  1.  `A` → `Z`
  2.  `b` → `y`
  3.  `c` → `x`
  4.  `1`、`2`、`3`：无映射，直接保留
- 加密结果：`"Zyx123"`

### 4.  C#代码实现（贴合中职编程基础）
```csharp
using System;

class ReplaceCipher
{
    static void Main(string[] args)
    {
        string originalStr = "Abc123";
        // 加密
        string encryptedStr = ReplaceEncrypt(originalStr);
        Console.WriteLine($"加密前：{originalStr}");
        Console.WriteLine($"加密后：{encryptedStr}");
        // 解密
        string decryptedStr = ReplaceDecrypt(encryptedStr);
        Console.WriteLine($"解密后：{decryptedStr}");
    }

    // 简单替换加密（字母倒序映射）
    static string ReplaceEncrypt(string str)
    {
        string result = "";
        foreach (char c in str)
        {
            // 大写字母：A(65)↔Z(90)，公式：90 - (c - 65)
            if (c >= 'A' && c <= 'Z')
            {
                result += (char)(90 - (c - 65));
            }
            // 小写字母：a(97)↔z(122)，公式：122 - (c - 97)
            else if (c >= 'a' && c <= 'z')
            {
                result += (char)(122 - (c - 97));
            }
            // 非字母直接保留
            else
            {
                result += c;
            }
        }
        return result;
    }

    // 简单替换解密（与加密公式相同，因为倒序映射是对称的）
    static string ReplaceDecrypt(string str)
    {
        // 倒序映射的加密和解密公式完全一致，直接调用加密方法即可
        return ReplaceEncrypt(str);
    }
}
```

### 运行结果
```
加密前：Abc123
加密后：Zyx123
解密后：Abc123
```

## 三、总结
1.  **核心流程**：所有基础加密算法都围绕「`字符 → ASCII码 → 变换处理 → 还原字符`」展开，熟记英文字母/数字的ASCII码范围是前提。
2.  **必考算法**：凯撒密码（移位加密）是笔试+编程的双重重点，必须掌握循环移位公式；简单替换密码（倒序映射）是笔试手动加密的高频考点。
3.  **关键技巧**：所有基础算法都是「可逆的」，加密与解密是逆过程，熟记每种算法的加密/解密公式，避免混淆。
4.  **注意事项**：非字母/数字字符（如空格、符号）通常直接保留，无需参与加密变换，这是笔试和编程题的常见要求。