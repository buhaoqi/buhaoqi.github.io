---
noteId: "33b7e1103eca11f081f2eb75db5e372e"
tags: []

---

## 整数类型是什么

整数类型用于存储整数(没有小数部分的数字)，包括正整数、负整数和零。

## 整数类型分类
根据取值范围的不同，C#提供了八种整数类型：


| 类型|术语| 大小| 范围| 后缀 | 默认值 |
|--|--|--|----|---------------|--------|
| **sbyte**   | 字节整型  | 1字节(8位)    | -128 到 127                                 |      | 0      |
| **byte**    |字节整型|1字节(8位)    |  0 到 255                                    |       | 0      |
| **short**   | 短整型  | 2字节(16位)   | `-32,768` 到 `32,767 `                          |      | 0      |
| **ushort**  | 短整型  | 2字节(16位)   | `0` 到 `65,535 `                                |      | 0      |
| **int**     | 整型 | 4字节(32位)   |-2,147,483,648 到 2,147,483,647             |       | 0      |
| **uint**    |整型 | 4字节(32位)   |0 到 4,294,967,295                          | u/U  | 0  |
| **long**    | 长整型| 8字节(64位)   | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 | l/L  | 0L     |
| **ulong**   | 长整型|8字节(64位)  |  0 到 18,446,744,073,709,551,615             | ul/UL| 0UL    | 

## 关于添加后缀的原因

C# 编译器默认将整数字面量视为 int 类型（32 位有符号整数），如2000000000默认被视为“int”类型，不加后缀会导致编译错误："整数太大，无法用 int 类型表示"。

- U：当数字较大时（接近或超过20亿），需要明确指定为无符号整数类型，这就是使用U后缀的原因。
- L：后缀显式告诉编译器："这是 long 类型"。提高代码可读性，明确表示处理大数字。



```c#
// 错误写法（不加L）
long myLong = 1000000000000; // 编译错误：数字太大

// 正确写法（加L后缀）
long myLong = 1000000000000L; // 正确
```

## 声明整型的语法

sbyte（8位有符号整数）：

      sbyte mySByte = -100;
   
byte（8位无符号整数）：

      byte myByte = 200;
   
short（16位有符号整数）：

      short myShort = -10000;
   
ushort（16位无符号整数）：

      ushort myUShort = 30000;
   
int（32位有符号整数）：

      int myInt = 1000000;
   
uint（32位无符号整数）：

      uint myUInt = 2000000000;
      uint myUInt = 2000000000U;
   
long（64位有符号整数）：

      long myLong = 1000000000000;
       long myLong = 1000000000000L;
   
ulong（64位无符号整数）：

      ulong myULong = 1000000000000000000;
      ulong myULong = 1000000000000000000UL;
   



## byte与int比较

在 C# 中存储年龄时，选择 `byte` 还是 `int` 取决于具体场景和需求。下面我将详细分析两种选择的优缺点，并提供实际建议。

### 对比分析表

| 特性 | byte (推荐) | int (常用) |
|------|-------------|------------|
| **内存占用** | 1字节 ✅ | 4字节 ❌ |
| **取值范围** | 0-255 (0-120 完全覆盖) ✅ | -20亿到+20亿 (远超需求) ❌ |
| **性能影响** | 微小优势 ✅ | 良好 ⚠️ |
| **类型转换** | 需要显式转换 ❌ | 无需转换 ✅ |
| **代码可读性** | 明确表示小范围数值 ✅ | 通用但不够精确 ⚠️ |
| **默认类型兼容** | 不兼容大多数API ❌ | 完美兼容 ✅ |
| **最佳适用场景** | 内存敏感应用、大数据集 | 通用开发、初学阶段 |

### 使用 `byte` 的优势

```csharp
byte age = 25; // 明确表示年龄是小范围值，推荐首选
```

**优点**：

- **内存高效**：1字节 vs int的4字节（节省75%内存）
- **范围精确**：0-255 完美覆盖人类年龄范围（0-120）
- **语义明确**：清晰表明这是小范围非负整数
- **大数据优势**：存储百万用户年龄可节省约 2.86MB 内存

  ```csharp
  // 100万用户年龄存储
  byte[] agesByte = new byte[1_000_000]; // 占用 0.95 MB
  int[] agesInt = new int[1_000_000];    // 占用 3.81 MB
  ```

**缺点**：

- 需要显式类型转换
- 不兼容期望int类型的API
- 超出255会抛出异常

### 使用 `int` 的优势
```csharp
int age = 25; // 默认整数类型，传统选择
```

**优点**：

- **无需转换**：直接用于数学运算
- **API兼容**：完美匹配大多数框架方法
- **开发便捷**：初学者友好
- **范围安全**：永不溢出（对年龄而言）

**缺点**：

- 内存浪费（每个年龄多占3字节）
- 语义不够精确（可表示负数和极大值）

## 使用场景
### INT使用场景

日常使用优先默认选择int：除非有特殊需求，否则优先使用int

- 大多数API使用int
- 性能最佳（32位系统优化）
- 范围足够日常使用（±21亿）
### BYTE使用场景

内存敏感场景使用`byte`/`sbyte` 如：

- 大型数组
- 如图像处理
- 网络传输：使用最小必要类型

```csharp
byte[] imageData = new byte[1024 * 1024]; // 1MB
```

### LONG使用场景
需要大范围整数使用long（最大支持9EB）或ulong，如：

- 文件大小
- 科学计算

```csharp
long fileSize = 15L * 1024 * 1024 * 1024; // 15GB
```

### UINT使用场景

无符号数仅无符号数场景，使用`uint`,如：
   
- 颜色值（ARGB）：

```csharp
uint color = 0xFFAABBCC; // 带透明度的颜色值
```

- 位掩码操作：uint/ulong

```csharp
const uint ReadPermission = 0b0001;
const uint WritePermission = 0b0010;
uint userPermissions = ReadPermission | WritePermission;
```

1. 类型转换时注意范围检查
2. 使用数字分隔符提高大数可读性
3. 涉及金融计算时使用`decimal`而非整数类型

## 数字分隔符

c#允许在数字字面量中使用下划线 _ 作为分隔符以提高代码可读性。

```csharp
long bigNumber = 9_223_372_036_854_775_807; // 提高可读性
```

- 数字分隔符 _ 仅用于提升代码可读性
- 编译时会完全忽略。
- 不改变数值的实际大小

使用规则

1.除去首尾，可在一个整数的任意位置添加分割符

```c#
int valid = 123_456;            // ✅ 合法
int invalid = _123;             // ❌ 错误：不能在开头
int invalid = 123_;             // ❌ 错误：不能在结尾
``` 
2.可以连续使用两个下划线，禁止连续使用三个下划线
```c#
int valid = 1__2__3;           // ✅ 合法（但建议避免过度使用）
int invalid = 1___23;          // ❌ 错误：连续三个下划线
``` 
3.分隔符兼容各种进制
```c#
int dec = 1_000_000;            // ✅ 十进制整数
double flt = 1_000.000_001;     // ✅ 浮点数
decimal mon = 1_000_000.99m;    // ✅ 十进制数
int hex = 0xDEAD_BEEF;          // ✅ 十六进制
int bin = 0b1010_0101_1100;     // ✅ 二进制
```   

常见应用场景
```c#
// 大数值分段
long worldPopulation = 8045311447; // 难以阅读
long worldPopulation = 8_045_311_447; // 立即理解为"80亿"

//浮点数分段
double pi = 3.141_592_653_589_793;// π 的近似值

//金融数值
decimal nationalDebt = 31_456_932_742_893.27m;// 百万美元金额

//二进制
uint ipMask = 0b1111_1111_1111_1111_0000_0000_0000_0000;// IP地址掩码

//十六进制数据分组
int transparentRed = 0x80_FF_00_00;// 颜色值（ARGB）

// 电话号码
long customerPhone = 1_800_555_1212;

// 产品代码
ulong productCode = 12_3456_7890_1234_5678;

//分隔符与类型后缀：
long big = 1_000_000_000_000L;  // ✅ L后缀在下划线后
   
//科学计数法：
double avogadro = 6.022_140_857e23; // ✅ 下划线在指数部分前
 
```
分组策略：

- 十进制：每3位分组（千位分隔）
- 十六进制：每4位分组（半字节/nibble）
- 二进制：每4位或8位分组

一致性原则：
```c#
int x = 10_0000;  // 混合分组不一致（不推荐）
int x = 100_000;  // 标准千位分隔,（推荐）
```  
避免过度使用：
```c#
int overSeparated = 1_0_0_0_0; // 过度分隔（不推荐）
int readable = 100_000;// 适度分隔（推荐）
``` 

## 整数的除法运算

整数除法会导致小数点被截断的行为。

示例

```c#
int n = 10 / 3;
Console.Write(n); //结果是3，而不是3.333333333
```
代码行为分析

- **操作数**：`10` 和 `3` 都是 `int` 类型。 `int / int`，输出仍是 `int`，**类型未改变**。 
- **运算规则**：当两个整数相除时，C# 执行**整数除法**，结果仍是 `int` 类型，**小数部分直接丢弃**（不是四舍五入）。
- **结果**：`10 / 3 = 3`（余数 1 被丢弃）。

示例：隐式转换

```c#
double n = 10 / 3;
Console.Write(n); //结果是3.0，而不是3。此时发生了**隐式转换**（`int` → `double`），但除法本身仍是整数除法。
```

示例：浮点数结果

```csharp
double correct1 = 10.0 / 3;  // 10.0 是 double，触发浮点除法 → 3.333...
double correct2 = 10 / 3.0;  // 3.0 是 double → 3.333...
double correct3 = (double)10 / 3; // 显式转换其中一个操作数
```

示例：`decimal` 的除法
`decimal` 会保留小数，但**必须所有操作数都是 `decimal`**：
```csharp
decimal n = 10m / 3m;  // 结果是 3.3333333333333333333333333333
```

总结

| 代码              | 运算类型       | 结果  | 是否涉及转换 |
|-------------------|---------------|-------|-------------|
| `int n = 10 / 3;` | 整数除法       | `3`   | ❌ 否        |
| `double n = 10 / 3;` | 整数除法 + 隐式转换 | `3.0` | ✅ 是（结果转换） |
| `double n = 10.0 / 3;` | 浮点除法     | `3.333...` | ❌ 否（操作数类型提升） |

**问题及修正方法**

| 问题类型               | 修正方法                          |
|------------------------|----------------------------------|
| **整数除法截断**       | 至少一个操作数转为 `double`/`decimal` |
| **浮点数精度问题**     | 使用 `double` 或 `decimal`        |
| **输入安全处理**       | 用 `TryParse` 替代 `Parse`        |
| **四舍五入需求**       | 使用 `Math.Round`                |


## 练习：单选题（15道）

**1. 以下哪个类型可以存储 `-128` 到 `127` 的整数？**  
A) `byte`  
B) `sbyte`  
C) `short`  
D) `ushort`  

---

**2. 如果要存储 `0` 到 `255` 的无符号整数，应该使用哪个类型？**  
A) `byte`  
B) `sbyte`  
C) `short`  
D) `int`  

---

**3. 以下哪个类型可以存储 `-32,768` 到 `32,767` 的整数？**  
A) `byte`  
B) `short`  
C) `ushort`  
D) `int`  

---

**4. 如果要存储 `65,535`，应该使用哪个类型？**  
A) `short`  
B) `ushort`  
C) `int`  
D) `uint`   

---

**5. `int` 类型的最大值是多少？**  
A) `2,147,483,647`  
B) `4,294,967,295`  
C) `32,767`  
D) `65,535`   

---

**6. 以下哪个类型可以存储 `4,294,967,295`？**  
A) `int`  
B) `uint`  
C) `long`  
D) `ulong`   

---

**7. 如果要存储 `9,223,372,036,854,775,807`，应该使用哪个类型？**  
A) `int`  
B) `uint`  
C) `long`  
D) `ulong`   

---

**8. `ulong` 的最大值是多少？**  
A) `9,223,372,036,854,775,807`  
B) `18,446,744,073,709,551,615`  
C) `4,294,967,295`  
D) `2,147,483,647`  

---

**9. 以下哪个是合法的 `int` 变量定义，并使用了数字分隔符 `_`？**  
A) `int num = 1_000_000;`  
B) `int num = 1.000.000;`  
C) `int num = 1,000,000;`  
D) `int num = 1 000 000;`   

---

**10. 以下哪个代码会导致编译错误？**  
A) `byte num = 255;`  
B) `sbyte num = -128;`  
C) `ushort num = 65_535;`  
D) `short num = 32_768;`   

---

**11. 以下哪个类型可以存储 `-1`？**  
A) `byte`  
B) `ushort`  
C) `uint`  
D) `long`  

---

**12. 如果要存储 `10_000_000_000`（100亿），应该使用哪个类型？**  
A) `int`  
B) `uint`  
C) `long`  
D) `ulong`  

---

**13. 以下哪个是合法的 `long` 变量定义？**  
A) `long num = 9_223_372_036_854_775_807;`  
B) `long num = 9,223,372,036,854,775,807;`  
C) `long num = 9 223 372 036 854 775 807;`  
D) `long num = 9223372036854775807L;`  

---

**14. 以下哪个代码不会编译？**  
A) `uint num = 4_294_967_295;`  
B) `int num = 2_147_483_648;`  
C) `ulong num = 18_446_744_073_709_551_615;`  
D) `long num = -9_223_372_036_854_775_808;`  

---

**15. 如果要存储 `0` 到 `18,446,744,073,709,551,615` 的无符号整数，应该使用哪个类型？**  
A) `long`  
B) `ulong`  
C) `uint`  
D) `int`   

---

## 练习：操作题（10道）

练习1. 声明一个变量存储人的年龄（0-120），最合适的整数类型是：

练习2：使用数字分隔符声明变量 `population` 表示 7,800,000,000：

练习3：存储温度传感器读数（-50到150℃）

练习4：存储文件大小（最大16TB）

练习5：存储RGB颜色值（0-255）

练习6：存储商品库存数量（0-65,000）

练习7：存储银行账户余额（分单位，最大100亿元）

练习8：存储海拔高度（-10,000到+20,000米）

练习9：存储网站访问计数器（可能超过42亿）

练习10：存储方向角度（0-359度）

---

## 练习：除法截断问题(10道)
**题目 1：基础整数除法**
**代码**：
```csharp
int result = 7 / 2;
Console.WriteLine(result);
```
**问题**：输出结果是多少？为什么会这样？  

---

**题目 2：变量整数除法**
**代码**：
```csharp
int a = 10, b = 3;
int result = a / b;
Console.WriteLine(result);
```
**问题**：输出结果是多少？如何修正以得到 `3.333...`？  

---

**题目 3：整数除法与浮点数转换**
**代码**：
```csharp
double result = 10 / 3;
Console.WriteLine(result);
```
**问题**：输出是 `3.0` 还是 `3.333...`？为什么？  

---

**题目 4：`decimal` 的精确除法**
**代码**：
```csharp
decimal result = 10 / 3;
Console.WriteLine(result);
```
**问题**：输出是 `3` 还是 `3.333...`？如何修正？  

---

**题目 5：混合类型运算**
**代码**：
```csharp
int a = 5, b = 2;
double result = a / b;
Console.WriteLine(result);
```
**问题**：输出是 `2.0` 还是 `2.5`？如何修正？  

---

**题目 6：`Math` 方法修正**
**代码**：
```csharp
int a = 7, b = 2;
int result = a / b;
Console.WriteLine(result);
```
**问题**：如何用 `Math.Round` 或 `Math.Ceiling` 修正？  

---

**题目 7：`checked` 防止溢出**
**代码**：
```csharp
int a = int.MaxValue, b = 2;
int result = a / b;
Console.WriteLine(result);
```
**问题**：如果 `a + b` 可能溢出，如何安全计算？  

---

**题目 8：`float` 和 `double` 的区别**
**代码**：
```csharp
float result1 = 10f / 3;
double result2 = 10.0 / 3;
Console.WriteLine(result1 == result2);
```
**问题**：输出是 `True` 还是 `False`？为什么？  

---

**题目 9：`Parse` 与除法结合**
**代码**：
```csharp
string input = "5";
int b = 2;
double result = int.Parse(input) / b;
Console.WriteLine(result);
```
**问题**：输出是 `2.0` 还是 `2.5`？如何修正？  

---

**题目 10：`TryParse` 安全修正**
**代码**：
```csharp
string input = "abc";
int b = 2;
int a = int.Parse(input);  // 可能抛出异常
double result = a / b;
```
**问题**：如何安全地处理非数字输入？  

---

## 参考答案（单选题）

✅ 1**答案：B) `sbyte`**  
✅ 2**答案：A) `byte`**  
✅ 3**答案：B) `short`**  
✅ 4**答案：B) `ushort`**  
✅ 5**答案：A) `2,147,483,647`**  
✅ 6**答案：B) `uint`**  
✅ 7**答案：C) `long`**  
✅ 8**答案：B) `18,446,744,073,709,551,615`**  
✅ 9**答案：A) `int num = 1_000_000;`**  
✅ 10**答案：D) `short num = 32_768;`（`short` 的最大值是 `32,767`）**  
✅ 11**答案：D) `long`**  
✅ 12**答案：C) `long`**  
✅ 13**答案：D) `long num = 9223372036854775807L;`（`L` 后缀表示 `long`）**  
✅ 14**答案：B) `int num = 2_147_483_648;`（超出 `int` 最大值）**  
✅ 15**答案：B) `ulong`** 

## 参考答案（操作题）

练习1. 声明一个变量存储人的年龄（0-120），最合适的整数类型是：
```csharp
byte age = 25;
Console.WriteLine("最适合数据类型：byte 或 int");
```

- 最适合数据类型：byte 或 int
- 原因：从内存占用和取值范围角度讲，byte类型最适合:1字节内存，无符号，范围0-255完全覆盖

练习2：使用数字分隔符声明变量 `population` 表示 7,800,000,000：
```csharp
ulong population = 7_800_000_000UL;
Console.WriteLine("最适合数据类型：long或者ulong");
```

- 最合适的数据类型：ulong 或 long
- 原因：需要表示约78亿（7,800,000,000），int最大21亿不够，uint最大42亿不够。考虑到人口数量是非负的，使用`ulong`更能表达无符号的特性。不过在实际开发中，`long`也经常被使用，因为它可以处理所有整数范围（正负），并且与很多API兼容。

练习3：存储温度传感器读数（-50到150℃）

```csharp
sbyte temperature = -5;
Console.WriteLine("最合适的数据类型：sbyte");
```

- 最合适的数据类型：sbyte
- 原因：1字节，有符号，范围-128到127完全覆盖

练习4：存储文件大小（最大16TB）
```csharp
ulong fileSize = 16UL * 1024 * 1024 * 1024 * 1024;
Console.WriteLine("最合适的数据类型：ulong");
```

16TB = 16 × 1024 × 1024 × 1024 × 1024 = 17,592,186,044,416 字节

- int（Int32）的最大值是 2,147,483,647（约 2GB），不够用。
- uint（UInt32）的最大值是 4,294,967,295（约 4GB），仍然不够。
- long（Int64）的最大值是 9,223,372,036,854,775,807（约 8EB），完全足够。
- ulong（UInt64）的最大值是 18,446,744,073,709,551,615（约 16EB），也完全足够。

推荐类型：ulong（无符号 64 位整数），因为文件大小不会为负数。

适用场景：存储文件、磁盘容量等大数值数据（最大支持 16EB）。

替代方案：long（有符号 64 位整数），如果后续计算可能涉及负数。

练习5：存储RGB颜色值（0-255）
```csharp
byte red = 255, green = 0, blue = 128;
Console.WriteLine("最合适的数据类型：byte");
```

- 最合适的数据类型：byte
- 原因：1字节无符号，完美匹配0-255范围


练习6：存储商品库存数量（0-65,000）
```csharp
ushort stockQuantity = 32_000;
Console.WriteLine("最合适的数据类型：ushort");
```

- 最合适的数据类型：ushort
- 原因：2字节无符号，范围0-65,535，比int节省内存

练习7：存储银行账户余额（分单位，最大100亿元）
```csharp
long balanceInCents = 1_000_000_000_000L;
Console.WriteLine("最合适的数据类型：long");
```

- 最合适的数据类型：long
- 原因：100亿=10,000,000,000元=1,000,000,000,000分，需要8字节


练习8：存储海拔高度（-10,000到+20,000米）
```csharp
short altitude = 8848; // 珠穆朗玛峰高度
Console.WriteLine("最合适的数据类型：short");
```

- 最合适的数据类型：short
- 原因：2字节有符号，范围-32,768到32,767完全覆盖


练习9：存储网站访问计数器（可能超过42亿）
```csharp
ulong visitCount = 5_000_000_000UL;
Console.WriteLine("最合适的数据类型：ulong");
```

- 最合适的数据类型：ulong
- 原因：需要处理极大无符号整数，最大18万亿亿


练习10：存储方向角度（0-359度）
```csharp
byte directionAngle = 90; // 正东方向
Console.WriteLine("最合适的数据类型：byte");
```

- 最合适的数据类型：byte
- 原因：1字节无符号，范围0-255足够表示（360度可用0-359）


## 练习(整数类型)
3.result 的值是多少？（注意数据类型）

```c#
double result = (20 - 3 * 4) / 2.0;
```
4.result 的值是多少？为什么？

```csharp
int a = 7;
int b = 2;
int result = a / b;
```

7.d 的值是多少？如何修正得到小数3.333？

```csharp
double d = 10 / 3;
```
8.m, n, p 的最终值分别是多少？

```csharp
int m = 8;
int n = --m * 3;
int p = n++ / 2;
```
10.result 的值是多少？

```c#
int result = 6 * 4 - 3 * 5 / 2;
```

## 答案(整数类型)
1. **`result=4.0`**  
   `3*4=12` → `20-12=8` → `8/2.0=4.0`（用2.0触发浮点除法）
2. **`result=3`**  
   整数除法截断小数 → `7/2=3.5` → 截断为3

   *%和*同级从左到右*
3. 
4. **`d=3.0`**  
   整数除法 `10/3=3` → 转double得3.0  
   **修正：** `double d = 10.0 / 3;`（至少一个操作数为浮点）
5. **`m=7, n=22, p=10`**  

   - `--m`：m先减为7 → `7*3=21`（n=21）  
   - `n++`：先用n=21 → `21/2=10`（整数除法，p=10） → n自增为22  
      *修正：实际n在p计算后自增，所以最终n=22？但题目中是`n++ / 2`，p计算后n会自增，所以最终n=22？但解析写n=23？有矛盾，应修正为：*  
      **修正解析**：  
   - 第一行后：m=7  
   - 第二行：`--m` 使m=7，计算得 n=7*3=21  
   - 第三行：`n++` 使用n的当前值21，计算 p=21/2=10（整数除法），然后n自增为22  
      **最终值**：m=7, n=22, p=10

10. result=19 
    `6*4=24` → `3*5=15` → `15/2=7`（整数除法） → `24-7=19`  
    *同优先级从左到右，但乘除高于加减*

## 答案(除法截断问题)
**题目 1：基础整数除法**
**代码**：
```csharp
int result = 7 / 2;
Console.WriteLine(result);
```
**问题**：输出结果是多少？为什么会这样？  
**修正方法**：如何修改代码以得到 `3.5`？

✅ **答案**：
- **输出**：`3`（整数除法，小数部分被丢弃）
- **修正**：
  ```csharp
  double result = 7.0 / 2;  // 或 (double)7 / 2
  ```

---

**题目 2：变量整数除法**
**代码**：
```csharp
int a = 10, b = 3;
int result = a / b;
Console.WriteLine(result);
```
**问题**：输出结果是多少？如何修正以得到 `3.333...`？  
✅ **修正**：
```csharp
double result = (double)a / b;
```

---

**题目 3：整数除法与浮点数转换**
**代码**：
```csharp
double result = 10 / 3;
Console.WriteLine(result);
```
**问题**：输出是 `3.0` 还是 `3.333...`？为什么？  
✅ **答案**：
- **输出**：`3.0`（因为 `10 / 3` 先进行整数除法，再隐式转换为 `double`）  
- **修正**：
  ```csharp
  double result = 10.0 / 3;
  ```

---

**题目 4：`decimal` 的精确除法**
**代码**：
```csharp
decimal result = 10 / 3;
Console.WriteLine(result);
```
**问题**：输出是 `3` 还是 `3.333...`？如何修正？  
✅ **修正**：
```csharp
decimal result = 10m / 3m;  // 必须加 'm' 后缀
```

---

**题目 5：混合类型运算**
**代码**：
```csharp
int a = 5, b = 2;
double result = a / b;
Console.WriteLine(result);
```
**问题**：输出是 `2.0` 还是 `2.5`？如何修正？  
✅ **修正**：
```csharp
double result = (double)a / b;
```

---

**题目 6：`Math` 方法修正**
**代码**：
```csharp
int a = 7, b = 2;
int result = a / b;
Console.WriteLine(result);
```
**问题**：如何用 `Math.Round` 或 `Math.Ceiling` 修正？  
✅ **修正**：
```csharp
double result = Math.Round((double)a / b, 1);  // 四舍五入保留 1 位小数
```

---

**题目 7：`checked` 防止溢出**
**代码**：
```csharp
int a = int.MaxValue, b = 2;
int result = a / b;
Console.WriteLine(result);
```
**问题**：如果 `a + b` 可能溢出，如何安全计算？  
✅ **修正**：
```csharp
checked {
    int result = a / b;  // 如果溢出会抛出异常
}
```

---

**题目 8：`float` 和 `double` 的区别**
**代码**：
```csharp
float result1 = 10f / 3;
double result2 = 10.0 / 3;
Console.WriteLine(result1 == result2);
```
**问题**：输出是 `True` 还是 `False`？为什么？  
✅ **答案**：
- **输出**：`False`（`float` 精度较低，`double` 更精确）

---

**题目 9：`Parse` 与除法结合**
**代码**：
```csharp
string input = "5";
int b = 2;
double result = int.Parse(input) / b;
Console.WriteLine(result);
```
**问题**：输出是 `2.0` 还是 `2.5`？如何修正？  
✅ **修正**：
```csharp
double result = double.Parse(input) / b;
```

---

**题目 10：`TryParse` 安全修正**
**代码**：
```csharp
string input = "abc";
int b = 2;
int a = int.Parse(input);  // 可能抛出异常
double result = a / b;
```
**问题**：如何安全地处理非数字输入？  
✅ **修正**：
```csharp
if (int.TryParse(input, out int a)) {
    double result = (double)a / b;
} else {
    Console.WriteLine("输入无效！");
}
```

---