---
noteId: "f62758a0741e11f0ac7f012540a4f7e6"
tags: []

---


# MySQL 中 DQL 的 GROUP BY 子句详解

在 MySQL 中，**DQL（Data Query Language，数据查询语言）** 是用于从数据库中**查询和检索数据**的核心语言，而 **`GROUP BY` 子句** 是 DQL 中用于**数据分组与聚合统计**的重要子句。

---

## 一、什么是 DQL 和 GROUP BY 子句？

### 🔍 DQL（Data Query Language）：数据查询语言

DQL 是 SQL 的四大子语言之一（其他为 DML、DDL、DCL），它专注于**查询数据**，不修改数据。其最常见的形式是：

```sql
SELECT ... FROM ...
```

当我们需要对查询结果进行**分组统计、汇总计算**时，就会用到：

```sql
GROUP BY ...
```

---

### 🎯 GROUP BY 子句的作用

> **`GROUP BY` 用于将查询结果按照一个或多个列的值进行分组，通常与聚合函数一起使用，对每组数据进行统计计算。**

简单来说：

- **GROUP BY 就是把数据按某个字段（或字段组合）进行“分类”**
- **然后可以对每一类数据进行汇总、计数、求平均等操作**

---

## 二、GROUP BY 子句的基本语法

```sql
SELECT 
    column1, 
    aggregate_function(column2)
FROM 
    table_name
GROUP BY 
    column1
[HAVING group_condition]
[ORDER BY ...]
[LIMIT ...];
```

> ✅ 说明：
> - `GROUP BY column1`：表示按照 `column1` 的值进行分组，**相同值的行会被分为一组**
> - 通常与 **聚合函数** 如 `COUNT()`, `SUM()`, `AVG()`, `MAX()`, `MIN()` 等一起使用
> - `HAVING` 是对分组后的结果进行过滤（类似 WHERE，但是作用于分组后）

---

## 三、GROUP BY 的核心功能与用法详解

---

### 1️⃣ 基础用法：按单列分组并统计

#### 🎯 场景：
统计每个部门的员工人数。

假设有一个员工表 `employees`：

```sql
CREATE TABLE employees (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    department VARCHAR(50),
    salary DECIMAL(10, 2)
);
```

#### ✅ 示例：统计每个部门的员工数量

```sql
SELECT 
    department, 
    COUNT(*) AS employee_count
FROM 
    employees
GROUP BY 
    department;
```

> 🧾 结果示例：

| department | employee_count |
|------------|----------------|
| IT         | 5              |
| HR         | 3              |
| Sales      | 7              |

> ✅ 说明：
> - 按 `department` 字段分组
> - 每组（每个部门）统计一次 `COUNT(*)`，即该部门有多少条记录（员工数）

---

### 2️⃣ 按多列分组

你可以按照**多个字段的组合**进行分组，只有当 **所有分组字段的值都相同** 时，才会被视为同一组。

#### ✅ 示例：按部门 AND 职位分组，统计人数

假设表中有 `position` 字段：

```sql
SELECT 
    department, 
    position, 
    COUNT(*) AS count
FROM 
    employees
GROUP BY 
    department, position;
```

> ✅ 说明：先按部门分组，再在每个部门内按职位分组，统计每类组合的人数

---

### 3️⃣ 配合聚合函数使用（重点）

`GROUP BY` **通常与聚合函数一起使用**，用于对每一组数据进行计算，比如：

| 函数 | 说明 | 示例 |
|------|------|------|
| `COUNT()` | 统计行数 / 记录数 | `COUNT(*)`, `COUNT(column)` |
| `SUM()` | 求和 | `SUM(salary)` |
| `AVG()` | 平均值 | `AVG(price)` |
| `MAX()` | 最大值 | `MAX(age)` |
| `MIN()` | 最小值 | `MIN(score)` |

#### ✅ 示例 1：查询每个部门的最高工资

```sql
SELECT 
    department, 
    MAX(salary) AS max_salary
FROM 
    employees
GROUP BY 
    department;
```

#### ✅ 示例 2：查询每个分类下的商品总销量和平均价格

```sql
SELECT 
    category, 
    SUM(quantity) AS total_sold,
    AVG(price) AS avg_price
FROM 
    products
GROUP BY 
    category;
```

---

### 4️⃣ HAVING 子句：对分组结果进行过滤

> **`HAVING` 用于对 `GROUP BY` 分组后的结果进行条件筛选，类似于 `WHERE`，但是 WHERE 是针对原始行，HAVING 是针对分组后的统计结果。**

#### ✅ 语法：
```sql
GROUP BY column
HAVING group_condition
```

#### ✅ 示例：查询员工数超过 5 人的部门

```sql
SELECT 
    department, 
    COUNT(*) AS employee_count
FROM 
    employees
GROUP BY 
    department
HAVING 
    COUNT(*) > 5;
```

> ✅ 说明：
> - `WHERE` 不能用于过滤聚合结果（比如 `COUNT(*) > 5` 是无效的）
> - 必须使用 `HAVING` 来筛选分组后的数据

---

### 5️⃣ GROUP BY 与 ORDER BY 结合：分组后排序

你可以对分组统计后的结果进行排序，比如按总销量降序、按平均分数排序等。

#### ✅ 示例：查询每个部门的平均工资，并按工资降序排列

```sql
SELECT 
    department, 
    AVG(salary) AS avg_salary
FROM 
    employees
GROUP BY 
    department
ORDER BY 
    avg_salary DESC;
```

---

## 四、GROUP BY 使用注意事项

| 注意事项 | 说明 |
|---------|------|
| **GROUP BY 的字段必须出现在 SELECT 中（除非是聚合函数）** | 如果你 `GROUP BY department`，那么 `SELECT` 中的字段要么是 `department`，要么是聚合函数如 `COUNT()`, `AVG()` 等 |
| **WHERE 用于行级过滤，HAVING 用于组级过滤** | WHERE 在分组前过滤行，HAVING 在分组后过滤组 |
| **聚合函数不能用在 WHERE 子句中** | 比如 `WHERE COUNT(*) > 5` 是错误的，应该用 `HAVING` |
| **可以按单列或多列分组** | 多列分组时，只有所有列值都相同的行才属于同一组 |
| **GROUP BY 通常与聚合函数配合使用才有意义** | 单独使用 `GROUP BY` 而无聚合函数，通常没有实际意义 |

---

## ✅ 总结：GROUP BY 子句核心要点速查

| 功能 | 说明 | 示例 |
|------|------|------|
| **分组统计** | 按某个字段或多个字段进行分组 | `GROUP BY department` |
| **聚合计算** | 配合 `COUNT()`, `SUM()`, `AVG()`, `MAX()`, `MIN()` 等使用 | `COUNT(*)`, `SUM(salary)` |
| **多列分组** | 按多个字段组合分组 | `GROUP BY department, position` |
| **分组过滤** | 使用 `HAVING` 对分组后的结果筛选 | `HAVING COUNT(*) > 5` |
| **排序结果** | 结合 `ORDER BY` 对分组统计结果排序 | `ORDER BY avg_salary DESC` |
| **与 WHERE 的区别** | WHERE 是对原始数据行过滤，HAVING 是对分组后的统计结果过滤 | `WHERE age > 18` vs `HAVING COUNT(*) > 5` |

---

## 📌 下一步建议

你可以继续尝试以下练习来巩固 `GROUP BY` 的使用：

1. ✅ 查询每个分类下的商品数量与平均价格
2. ✅ 统计每个部门的员工人数，并筛选出人数大于 3 的部门
3. ✅ 按月份分组统计订单数量和总金额
4. ✅ 使用多列分组（如部门 + 职位）统计平均薪资
5. ✅ 结合 `ORDER BY` 将分组结果按某个统计值排序

---

如你希望获取：

- ✅ 带有 **实际建表 + 数据 + 复杂 GROUP BY 查询** 的完整示例
- ✅ 如何在 **报表统计、数据看板、BI分析** 中使用 GROUP BY
- ✅ 或者 `GROUP BY` 与 **窗口函数、子查询、JOIN** 结合的高级用法

欢迎继续提问！我可以为你提供详细的实战 SQL 代码与讲解。



# ✅ MySQL 中 GROUP BY 语句的典型用法详解

在 MySQL 中，**`GROUP BY`** 是一个非常重要且强大的 SQL 子句，它用于：

> **将查询结果按照一个或多个字段进行分组，通常与聚合函数（如 COUNT、SUM、AVG、MAX、MIN 等）一起使用，对每组数据进行汇总计算。**

---

## 🎯 一、GROUP BY 是什么？

简单来说：

> **GROUP BY 的作用就是“分组”，它把数据按照你指定的字段值进行归类，然后你可以对每一组数据进行统计、求和、求平均等操作。**

---

## 🧠 二、为什么需要 GROUP BY？

在实际业务中，我们经常需要：

- 统计每个班级的学生人数
- 计算每个性别的平均年龄
- 汇总每个部门的工资总额
- 找出每个产品的总销量
- 分析每天的订单数量

这些需求都涉及到：**按某个字段的不同值，对数据进行分组，再对每组进行聚合计算**。

这时候，就需要用到 `GROUP BY`。

---

## 📦 三、GROUP BY 的基本语法

```sql
SELECT 
    分组字段1, 分组字段2, ...,  -- 用于分组的字段
    聚合函数(字段)               -- 如 COUNT(), SUM(), AVG() 等
FROM 
    表名
[WHERE 条件]
GROUP BY 
    分组字段1, 分组字段2, ...;
```

> ✅ **要点：**
>
> - `GROUP BY` 后面跟的是你想要**按照哪些字段来分组**
> - SELECT 中的**非聚合列，一般要出现在 GROUP BY 中**
> - 通常与 **COUNT、SUM、AVG、MAX、MIN** 等聚合函数一起使用

---

## 🎮 四、GROUP BY 的典型用法与实例详解

---

### 📌 示例表：students（学生表）

```sql
CREATE TABLE students (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    age INT,
    gender VARCHAR(10),
    score DECIMAL(5,2),
    class_id INT
);

INSERT INTO students VALUES
(1, '小明', 18, '男', 88.5, 1),
(2, '小红', 19, '女', 92.0, 1),
(3, '小刚', 18, '男', 76.5, 1),
(4, '小丽', 20, '女', 85.0, 2),
(5, '小华', 19, '男', 90.0, 2),
(6, '小芳', 18, '女', 88.0, 2);
```

---

## 🔹 用法 1：单字段分组 —— 按班级统计学生人数

### ✅ 查询：每个班级有多少学生？

```sql
SELECT 
    class_id,
    COUNT(*) AS 学生人数
FROM students
GROUP BY class_id;
```

🔍 结果：

| class_id | 学生人数 |
|----------|---------|
| 1        | 3       |
| 2        | 3       |

> 🎯 说明：
> - 按 `class_id` 分组，每组（每个班级）统计一次
> - `COUNT(*)` 计算每组的行数，即学生人数

---

## 🔹 用法 2：单字段分组 —— 按性别统计平均年龄

### ✅ 查询：每个性别的平均年龄是多少？

```sql
SELECT 
    gender,
    AVG(age) AS 平均年龄
FROM students
GROUP BY gender;
```

🔍 结果可能为：

| gender | 平均年龄 |
|--------|---------|
| 男     | 18.3    |
| 女     | 19.0    |

> ✅ 按性别分组后，分别计算每组的平均年龄

---

## 🔹 用法 3：单字段分组 —— 按班级统计平均分

### ✅ 查询：每个班级的平均成绩是多少？

```sql
SELECT 
    class_id,
    AVG(score) AS 班级平均分
FROM students
GROUP BY class_id;
```

🔍 结果可能为：

| class_id | 班级平均分 |
|----------|-------------|
| 1        | 85.67       |
| 2        | 87.67       |

---

## 🔹 用法 4：多字段分组 —— 按班级和性别分组统计人数

### ✅ 查询：每个班级中，每个性别有多少人？

```sql
SELECT 
    class_id,
    gender,
    COUNT(*) AS 人数
FROM students
GROUP BY class_id, gender;
```

🔍 结果可能为：

| class_id | gender | 人数 |
|----------|--------|------|
| 1        | 男     | 2    |
| 1        | 女     | 1    |
| 2        | 男     | 1    |
| 2        | 女     | 2    |

> ✅ 按 **两个字段组合（class_id + gender）** 进行分组，统计每组人数

---

## 🔹 用法 5：结合 WHERE 条件过滤后再分组

### ✅ 查询：年龄大于 18 岁的每个班级有多少学生？

```sql
SELECT 
    class_id,
    COUNT(*) AS 学生人数
FROM students
WHERE age > 18
GROUP BY class_id;
```

🔍 先筛选 `age > 18` 的学生，再按班级分组统计

---

## 🔹 用法 6：结合聚合函数统计多个指标

### ✅ 查询：每个班级的学生人数、最高分、最低分、平均分

```sql
SELECT 
    class_id,
    COUNT(*) AS 人数,
    MAX(score) AS 最高分,
    MIN(score) AS 最低分,
    AVG(score) AS 平均分
FROM students
GROUP BY class_id;
```

🔍 输出示例：

| class_id | 人数 | 最高分 | 最低分 | 平均分 |
|----------|------|--------|--------|--------|
| 1        | 3    | 92.00  | 76.50  | 85.67  |
| 2        | 3    | 90.00  | 85.00  | 87.67  |

> ✅ 这是典型的 **多指标分组统计报表**，在数据分析中非常常见！

---

## 🔹 用法 7：GROUP BY 与 ORDER BY 结合 —— 按平均分排序

### ✅ 查询：每个班级的平均分是多少，并按平均分从高到低排序

```sql
SELECT 
    class_id,
    AVG(score) AS 平均分
FROM students
GROUP BY class_id
ORDER BY 平均分 DESC;
```

🔍 结果按平均分降序显示，便于找出成绩最好的班级

---

## ❗ 八、GROUP BY 使用注意事项

| 注意事项 | 说明 |
|---------|------|
| **SELECT 中的非聚合列** | 通常要出现在 `GROUP BY` 中，否则 MySQL 可能报错（严格 SQL 模式下）或返回不可预期的结果 |
| **聚合函数** | 如 COUNT(), SUM(), AVG(), MAX(), MIN() 等，用于对每组数据进行计算 |
| **WHERE 与 GROUP BY 的顺序** | **先 WHERE 过滤行，再 GROUP BY 分组** |
| **HAVING 子句** | 用于对分组后的结果进行筛选（类似 WHERE，但是作用于分组后，后面会详解） |
| **GROUP BY 可以多字段** | 按多个字段的组合值进行分组，如 `GROUP BY class_id, gender` |

---

## ✅ 九、总结：GROUP BY 典型用法一览

| 应用场景 | 示例 | 说明 |
|---------|------|------|
| **单字段分组统计** | 按班级统计人数：`GROUP BY class_id` | 每个班级为一组 |
| **多字段组合分组** | 按班级和性别分组：`GROUP BY class_id, gender` | 多个字段值组合为一组 |
| **聚合计算** | `COUNT(*)`, `AVG(score)`, `MAX(score)` 等 | 对每组数据进行汇总 |
| **结合 WHERE 过滤** | 先筛选再分组 | 如：`WHERE age > 18 GROUP BY class_id` |
| **结合排序** | 按平均分排序：`ORDER BY AVG(score) DESC` | 对分组统计结果排序 |
| **综合报表** | 每组人数、最高/最低/平均分 | 典型业务分析场景 |

---

## 🎓 十、一句话总结

> **GROUP BY 的作用就是“分组”，它让你能够按照某个或某些字段的值，把数据分成多个组，然后对每组数据进行统计、求和、求平均等操作，是数据分析与统计查询的核心工具。**

---

🙋 **如果你有具体的业务需求，比如：**

- “统计每个部门的员工数和平均工资”
- “找出每个商品类别的销量冠军”
- “分析每天的订单数量和金额”


## **MySQL 中 `GROUP BY` 群组的用法详解**

`GROUP BY` 是 SQL 中用于对查询结果按指定列群组的核心语句，通常与聚合函数（如 `COUNT`、`SUM`、`AVG` 等）结合使用，实现数据的群组统计和分析。以下是其用法详解：

核心作用

1. **数据群组**  
   将表中数据按指定列的值群组，相同值的行归为一组。
2. **群组统计**  
   对每组数据应用聚合函数，计算汇总值（如总和、平均值、最大值等）。

---

## 典型应用场景
### **1. 单列群组**
统计每个部门的员工数量：

```sql
SELECT department, COUNT(*) AS employee_count
FROM employees
GROUP BY department;
```
**结果示例**：

| department | employee_count |
|------------|----------------|
| 财务部     | 8              |
| 开发部     | 12             |
| 市场部     | 10             |

---

### **2. 多列群组**
统计每个部门中不同职位的员工数量：

```sql
SELECT department, job, COUNT(*) AS count
FROM employees
GROUP BY department, job;
```
**结果示例**：

| department | job       | count |
|------------|-----------|-------|
| 开发部     | Java开发  | 5     |
| 开发部     | 前端开发  | 3     |
| 市场部     | 市场策划  | 4     |

---

### **3. 结合聚合函数**
计算每个部门的平均薪资和最高薪资：

```sql
SELECT 
    department,
    ROUND(AVG(salary), 2) AS avg_salary,
    MAX(salary) AS max_salary
FROM employees
GROUP BY department;
```
**结果示例**：

| department | avg_salary | max_salary |
|------------|------------|------------|
| 财务部     | 8500.00    | 12000.00   |
| 开发部     | 14500.00   | 20000.00   |

---

### **4. 群组后过滤（HAVING）**
筛选员工数量超过 5 人的部门：

```sql
SELECT department, COUNT(*) AS count
FROM employees
GROUP BY department
HAVING count > 5;
```
**结果示例**：

| department | count |
|------------|-------|
| 开发部     | 12    |
| 市场部     | 10    |

---

## **四、关键注意事项**
1. **`SELECT` 列的合法性**  
   - `SELECT` 中的列必须是聚合函数或包含在 `GROUP BY` 子句中。  
   - **错误示例**：`SELECT name, department FROM employees GROUP BY department;`（`name` 未聚合或群组）。

2. **`WHERE` vs `HAVING`**  
   - `WHERE`：在群组前过滤数据，作用于原始数据行。  
   - `HAVING`：在群组后过滤数据，作用于群组结果。
    
   ```sql
   -- 查询财务部中平均薪资超过 10000 的职位
   SELECT job, AVG(salary) AS avg_salary
   FROM employees
   WHERE department = '财务部'
   GROUP BY job
   HAVING avg_salary > 10000;
   ```

3. **群组顺序与性能**  
   - 群组的字段顺序会影响结果，但不影响统计值（如 `GROUP BY A, B` 和 `GROUP BY B, A` 结果不同）。  
   - 为群组字段添加索引可提升性能（如 `CREATE INDEX idx_department ON employees(department)`）。

4. **`WITH ROLLUP` 小计功能**  
   生成群组汇总的小计行（需 MySQL 8.0+ 支持）：

   ```sql
   SELECT department, COUNT(*) AS count
   FROM employees
   GROUP BY department WITH ROLLUP;
   ```
   **结果示例**：

   | department | count |
   |------------|-------|
   | 财务部     | 8     |
   | 开发部     | 12    |
   | NULL       | 20    |  -- 总计行

---

## **五、常见错误及解决方案**
### **错误 1：非聚合字段未包含在 GROUP BY 中**
```sql
-- 错误：name 未群组或聚合
SELECT name, department, COUNT(*) 
FROM employees 
GROUP BY department;
```
**修复**：  
```sql
SELECT department, COUNT(*) 
FROM employees 
GROUP BY department;
```

### **错误 2：群组字段与聚合字段混淆**
```sql
-- 错误：salary 未聚合，但未群组
SELECT department, salary 
FROM employees 
GROUP BY department;
```
**修复**：  
```sql
SELECT department, MAX(salary) 
FROM employees 
GROUP BY department;
```

---

## **六、性能优化建议**
1. **索引优化**  
   - 为群组字段（如 `department`）和过滤字段（如 `hiredate`）添加复合索引：  
     ```sql
     CREATE INDEX idx_department_hiredate ON employees(department, hiredate);
     ```

2. **减少群组字段数量**  
   群组字段越多，性能开销越大，需按业务需求精简。

3. **使用覆盖索引**  
   若查询只需索引字段和聚合结果，可避免回表：  
   ```sql
   -- 假设存在索引 (department, salary)
   SELECT department, AVG(salary) 
   FROM employees 
   GROUP BY department;
   ```

---
## **总结**
- **核心作用**：按列群组并统计汇总数据。
- **常用组合**：`GROUP BY` + 聚合函数（`COUNT`、`SUM`、`AVG` 等）。
- **过滤时机**：`WHERE` 群组前过滤，`HAVING` 群组后过滤。
- **优化关键**：索引设计、减少群组字段、避免不必要计算。



---



## 练习

### 查询员工信息

创建员工信息表

表(yuangong | employees )结构要求：

- id 
- 员工编号（empno）: 格式：D001，唯一
- 姓名（ename）
- 性别（gender）
- 年龄（age） 22-60
- 学历（education） :'大专','本科','研究生'
- 身份证号（d_card）:唯一  18位
- 省份（province） 
- 城市（city）
- 电邮（email）
- 薪水（salary）
- 职位（job）
- 部门（department）:'财务部','人力部','设计部','开发部','市场部','行政部','后勤部'
- 入职日期（hiredate）

插入数据

```sql
INSERT INTO employees (e_id, e_name, e_gender, e_age, e_education, e_id_card, e_province, e_city, e_email, e_salary, e_job, e_department, e_hiredate) VALUES
('D001', '张伟', '男', 35, '本科', '130402198803124512', '河北', '邯郸', 'zhangwei@163.com', 12500.00, '技术总监', '技术部', '2018-06-15'),
('D002', '王芳', '女', 28, '研究生', '410105199504237894', '河南', '郑州', 'wangfang@qq.com', 9800.00, 'HR', '人力部', '2020-09-22'),
('D003', '李强', '男', 42, '大专', '370103198101018976', '山东', '济南', 'liqiang@126.com', 8500.00, '电工', '后勤部', '2015-11-30'),
('D004', '赵敏', '女', 31, '本科', '14010619920131456X', '山西', '太原', 'zhaomin@sohu.com', 7200.00, '会计', '财务部', '2019-03-18'),
('D005', '陈勇', '男', 38, '本科', '130403198511209871', '河北', '邢台', 'chenyong@163.com', 11000.00, '市场总监', '市场部', '2017-08-09'),
('D006', '杨丽', '女', 27, '研究生', '410185199604157893', '河南', '安阳', 'yangli@qq.com', 13500.00, '设计师', '技术部', '2021-02-14'),
('D007', '黄建国', '男', 45, '大专', '370202197802287895', '山东', '济南', 'huangjg@126.com', 6800.00, '保安', '后勤部', '2016-05-25'),
('D008', '周晓梅', '女', 29, '本科', '140107199304198762', '山西', '太原', 'zhouxm@sohu.com', 9200.00, '行政主管', '行政部', '2020-07-11'),
('D009', '吴斌', '男', 33, '本科', '130404198910231234', '河北', '邯郸', 'wubin@163.com', 10500.00, '程序员', '技术部', '2019-11-05'),
('D010', '徐丽华', '女', 36, '研究生', '410102198705129876', '河南', '郑州', 'xulihua@qq.com', 14200.00, '人力总监', '人力部', '2017-04-27'),
('D011', '孙志强', '男', 40, '大专', '370104198212045678', '山东', '济南', 'sunzq@126.com', 7500.00, '后勤主任', '后勤部', '2018-12-01'),
('D012', '朱婷婷', '女', 26, '本科', '140108199702098765', '山西', '太原', 'zhutt@sohu.com', 6500.00, '办公文员', '行政部', '2022-08-19'),
('D013', '马军', '男', 37, '本科', '130405198608174321', '河北', '邢台', 'majun@163.com', 11500.00, '销售员', '市场部', '2016-09-12'),
('D014', '何静', '女', 32, '研究生', '410103199011239874', '河南', '安阳', 'hejing@qq.com', 12800.00, '技术总监', '技术部', '2019-07-25'),
('D015', '高伟', '男', 44, '大专', '370105197912318976', '山东', '济南', 'gaowei@126.com', 7000.00, '电工', '后勤部', '2017-10-30'),
('D016', '林雪', '女', 30, '本科', '140109199304217896', '山西', '太原', 'linxue@sohu.com', 8800.00, 'HR', '人力部', '2020-04-15'),
('D017', '郑强', '男', 39, '本科', '130406198408129876', '河北', '邯郸', 'zhengq@163.com', 13200.00, '财务总监', '财务部', '2018-03-22'),
('D018', '王秀兰', '女', 34, '研究生', '410104198907058765', '河南', '郑州', 'wangxl@qq.com', 9500.00, '设计师', '技术部', '2021-01-07'),
('D019', '冯刚', '男', 41, '大专', '370106198102237894', '山东', '济南', 'fenggang@126.com', 7200.00, '保安', '后勤部', '2019-06-18'),
('D020', '曾敏', '女', 28, '本科', '140110199502128763', '山西', '太原', 'zengmin@sohu.com', 10500.00, '程序员', '技术部', '2022-02-28'),
('D021', '程建国', '男', 46, '大专', '130407197708049875', '河北', '邢台', 'chengjg@163.com', 6800.00, '后勤主任', '后勤部', '2015-12-14'),
('D022', '蔡晓丽', '女', 31, '研究生', '410105199211157896', '河南', '安阳', 'caixl@qq.com', 14500.00, '市场总监', '市场部', '2020-11-09'),
('D023', '彭伟', '男', 35, '本科', '370107198803214567', '山东', '济南', 'pengwei@126.com', 9200.00, '行政主管', '行政部', '2018-07-03'),
('D024', '苏婷婷', '女', 29, '本科', '140111199402038762', '山西', '太原', 'sutt@sohu.com', 7500.00, '会计', '财务部', '2021-09-17'),
('D025', '蒋军', '男', 38, '本科', '130408198509127894', '河北', '邯郸', 'jiangjun@163.com', 11800.00, '销售员', '市场部', '2017-04-05'),
('D026', '叶静', '女', 33, '研究生', '410106198812319875', '河南', '郑州', 'yejing@qq.com', 13800.00, '人力总监', '人力部', '2019-08-21'),
('D027', '崔志强', '男', 43, '大专', '370108198001018976', '山东', '济南', 'cuizq@126.com', 7000.00, '电工', '后勤部', '2016-10-12'),
('D028', '邹雪梅', '女', 27, '本科', '140112199602098764', '山西', '太原', 'zouxm@sohu.com', 8500.00, '办公文员', '行政部', '2022-03-25'),
('D029', '白勇', '男', 36, '本科', '130409198708237895', '河北', '邢台', 'baiyong@163.com', 12500.00, '技术总监', '技术部', '2018-11-14'),
('D030', '石丽华', '女', 34, '研究生', '410107198911049876', '河南', '安阳', 'shilh@qq.com', 14200.00, '设计师', '技术部', '2020-06-07'),
('D031', '丁斌', '男', 39, '本科', '370109198208159874', '山东', '济南', 'dingbin@126.com', 9800.00, '程序员', '技术部', '2017-12-19'),
('D032', '杜晓梅', '女', 30, '本科', '140113199304128765', '山西', '太原', 'duxiaomei@sohu.com', 11500.00, '财务总监', '财务部', '2021-04-30'),
('D033', '夏刚', '男', 44, '大专', '130410197912318976', '河北', '邯郸', 'xiagang@163.com', 7200.00, '保安', '后勤部', '2019-02-11'),
('D034', '钟秀兰', '女', 32, '研究生', '410108199105239875', '河南', '郑州', 'zhongxl@qq.com', 13500.00, '市场总监', '市场部', '2018-05-26'),
('D035', '汪伟', '男', 37, '本科', '370110198510127894', '山东', '济南', 'wangwei@126.com', 10500.00, '行政主管', '行政部', '2020-10-09'),
('D036', '田敏', '女', 28, '本科', '140114199602178763', '山西', '太原', 'tianmin@sohu.com', 8800.00, 'HR', '人力部', '2022-01-23'),
('D037', '任建国', '男', 45, '大专', '130411198002287895', '河北', '邢台', 'rengjg@163.com', 6800.00, '后勤主任', '后勤部', '2016-07-15'),
('D038', '孟静', '女', 31, '研究生', '410109199011158976', '河南', '安阳', 'mengjing@qq.com', 14500.00, '技术总监', '技术部', '2021-08-04'),
('D039', '康军', '男', 40, '本科', '370111198312049875', '山东', '济南', 'kangjun@126.com', 13200.00, '销售员', '市场部', '2019-10-17'),
('D040', '侯婷婷', '女', 29, '本科', '140115199403028764', '山西', '太原', 'houtt@sohu.com', 9500.00, '会计', '财务部', '2022-05-12'),
('D041', '龙强', '男', 38, '本科', '130412198509217896', '河北', '邯郸', 'longqiang@163.com', 11800.00, '程序员', '技术部', '2017-09-28'),
('D042', '龚雪', '女', 33, '研究生', '410110198810319874', '河南', '郑州', 'gongxue@qq.com', 12800.00, '人力总监', '人力部', '2020-12-05'),
('D043', '文志强', '男', 42, '大专', '370112198101108976', '山东', '济南', 'wenzq@126.com', 7500.00, '电工', '后勤部', '2018-04-19'),
('D044', '包晓丽', '女', 30, '本科', '140116199402238765', '山西', '太原', 'baoxiaoli@sohu.com', 10500.00, '办公文员', '行政部', '2021-07-14'),
('D045', '左勇', '男', 39, '本科', '130413198408129875', '河北', '邢台', 'zuoyong@163.com', 13800.00, '设计师', '技术部', '2019-01-29'),
('D046', '江丽华', '女', 35, '研究生', '410111198705049876', '河南', '安阳', 'jianglh@qq.com', 14200.00, '市场总监', '市场部', '2017-06-22'),
('D047', '段斌', '男', 43, '大专', '370113198002237895', '山东', '济南', 'duanbin@126.com', 7000.00, '保安', '后勤部', '2016-08-11'),
('D048', '刘秀梅', '女', 34, '本科', '140117199301158764', '山西', '太原', 'liuxiumei@sohu.com', 9200.00, '行政主管', '行政部', '2020-03-07'),
('D049', '陆伟', '男', 41, '本科', '130414198210319874', '河北', '邯郸', 'luwei@163.com', 12500.00, '技术总监', '技术部', '2018-10-16'),
('D050', '黎静', '女', 36, '研究生', '410112198806128975', '河南', '郑州', 'lijing@qq.com', 13500.00, '财务总监', '财务部', '2021-11-27');
```

查询员工信息表

1. 查询年龄小于 30 的员工信息。
1. 查询年龄大于等于 50 的员工信息
1. 查询年龄等于 30 的员工信息
1. 查询年龄不等于 30 的员工信息
1. 查询没有身份证号的员工信息
1. 查询有身份证号的员工信息
1. 查询年龄在25岁(包含) 到 35岁(包含)之间的员工信息
1. 查询性别为 女 且年龄小于 30岁的员工信息
1. 查询年龄等于 30 或 40 或 50 的员工信息
1. 查询姓名为两个字的员工信息
1. 查询身份证号最后一位是X的员工信息
1. 根据年龄对公司的员工进行升序排序
1. 根据入职时间, 对员工进行降序排序
1. 根据年龄对公司的员工进行升序排序 , 年龄相同 , 再按照入职时间进行降序排序
1. 去重查询部门名称

### 统计平均薪资
统计 2020 年后入职的员工中，各部门不同学历的平均薪资（仅显示平均薪资 > 10000 的组）：
```sql
SELECT 
    department, 
    education,
    ROUND(AVG(salary), 2) AS avg_salary
FROM employees
WHERE hiredate >= '2020-01-01'
GROUP BY department, education
HAVING avg_salary > 10000
ORDER BY department;
```

**结果示例**：

| department | education | avg_salary |
|------------|-----------|------------|
| 开发部     | 研究生    | 15000.00   |
| 市场部     | 本科      | 12000.00   |


## 综合示例

查询年龄大于 18 岁的学生，显示姓名、年龄、分数，按分数降序，只看前 3 名：

```sql
SELECT name, age, score
FROM students
WHERE age > 18
ORDER BY score DESC
LIMIT 3;
```