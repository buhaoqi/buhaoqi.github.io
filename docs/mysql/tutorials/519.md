---
noteId: "bc252c50336d11f08c28b53ca771472d"
tags: []

---

## 5月19日：数学函数

考试大纲中的数学函数包括6个：ABS()、FLOOR()、RAND()、TRUNCATE()、SORT() 、ROUND()

我们要学的函数有10个，增加了4个：**CEIL()**、**MOD()** 、**POW()** 、**FORMAT()**

---

## **一、数学运算函数**

1. **ABS(x)**  
   - 作用：取绝对值  
   - 示例：`SELECT ABS(-12.5);  -- 输出 12.5`  
   - 场景：计算价格波动、温差等需要无方向数值的场景

2. **MOD(n, m)**  
   - 作用：取余数  
   - 示例：`SELECT MOD(15, 4);  -- 输出 3`  
   - 注意：结果符号与 n 相同，`MOD(-15,4)` 返回 `-3`

3. **POW(x, y) / POWER(x, y)**  
   - 作用：计算 x 的 y 次方  
   - 示例：`SELECT POW(2, 3);  -- 输出 8`

4. **SQRT(x)**  
   - 作用：平方根计算  
   - 示例：`SELECT SQRT(9);  -- 输出 3`  
   - 限制：x 必须为非负数

---

## **二、数值处理函数**

1. **CEIL(x) / CEILING(x)**  

   - 作用：向上取整  
   - 示例：`SELECT CEIL(3.1);  -- 输出 4`  
   - 注意：对负数 `CEIL(-3.1)` 返回 `-3`

2. **FLOOR(x)**  

   - 作用：向下取整  
   - 示例：`SELECT FLOOR(3.9);  -- 输出 3`  
   - 场景：计算商品整箱数量、分页计算等

3. **ROUND(x, d)**  

   - 作用：四舍五入到指定小数位  

   - 示例：  

     ```sql
     SELECT ROUND(3.1415, 2);  -- 输出 3.14  
     SELECT ROUND(123.456, -1); -- 输出 120（十位取整）
     ```

4. **TRUNCATE(x, d)**  

   - 作用：直接截断小数位  
   - 示例：`SELECT TRUNCATE(3.1415, 2);  -- 输出 3.14`  
   - 对比：与 ROUND 不同，不会四舍五入

5. **FORMAT(x, d)**  

   - 作用：数字格式化（千分位）  

   - 示例：  

     ```sql
     SELECT FORMAT(1234567.456, 2);  
     -- 输出 '1,234,567.46'（会四舍五入）
     ```

---

## **三、其他函数**

1. **RAND()**  

用途

生成 [0~1)之间的随机浮点数。

语法

```sql
RAND();
```

示例:生成一个0 ~ 1之间(不含1）的随机小数

```sql
SELECT RAND();
```

运行结果

```sql
+--------------------+
| rand()             |
+--------------------+
| 0.5100285648461698 |
+--------------------+
1 row in set (0.001 sec)
```

语法

```sql
-- 生成整数
floor(起始值 + RAND() * 范围长度)
-- 生成小数
floor(起始值 + RAND() * 范围长度) / 范围长度
```

在 MySQL 中生成随机整数的通用公式如下：

 基本公式

```sql
FLOOR(起始值 + RAND() * 范围长度)
```

在 MySQL 中生成 **包含 0 和 1** 的随机小数的公式为：

公式与解释

```sql
-- 生成 [0,1] 的随机小数（含 0 和 1）
SELECT FLOOR(RAND() * (N + 1)) / N;
```

示例：生成一个0~1之间（含1）的小数（1位）

```sql
SELECT FLOOR(RAND() * (10 + 1))/10;
```

运行结果

```sql
+-------------------+
| rand() * 10       |
+-------------------+
| 9.859416549894416 |
+-------------------+
1 row in set (0.001 sec)
```

示例: 生成一个10~20之间的小数

```sql
SELECT 10 + RAND() * 10;
```

示例：生成 1-100 的随机整数

```sql
SELECT FLOOR(1 + RAND() * 100);
```


---

## 四、应用场景

| 场景         | 解决方案 | 示例                                  |
| ------------ | -------- | ------------------------------------- |
| 价格精确到分 | TRUNCATE | `TRUNCATE(price, 2)`                  |
| 生成随机折扣 | RAND     | `ROUND(0.8 + RAND()*0.2, 2)`          |
| 分页计算     | CEIL     | `CEIL(total_records / page_size)`     |
| 奇偶判断     | MOD      | `MOD(id, 2) = 0`                      |
| 数据脱敏     | RAND     | `CONCAT('用户', FLOOR(RAND()*10000))` |

---

## 五、注意事项

1. 浮点精度问题：  

   ```sql
   -- 错误方式（可能得到错误结果）
   WHERE price = 3.14
   
   -- 正确方式（使用范围判断）
   WHERE price BETWEEN 3.135 AND 3.145
   ```

2. 性能优化：  

   - 避免在 WHERE 条件中使用函数计算  
   - 对大表慎用 `ORDER BY RAND()`

3. 函数嵌套顺序：  

   ```sql
   -- 正确：先计算绝对值再取余
   SELECT MOD(ABS(-10), 3);  -- 输出 1
   ```

掌握这些函数后，可覆盖 90% 的数值处理需求。建议结合具体业务场景多加练习，特别注意不同函数处理负数和小数时的行为差异。

## 六、 练习:生成随机数

1. 生成 0~5 的随机整数(包含 0 和 5)
1. 生成 **1~8** 的随机整数(包含 1 和 8)
1. 生成 **10~20** 的随机整数
1. 掷骰子（1~6）
1. 随机抽奖（100~999）
1. 随机布尔值（0/1）
1. 生成两位小数的随机数（含 0 和 1）
1. 生成四位小数的随机数（含 0 和 1）

## 六、 答案:生成随机数

1. 生成 **0~5** 的随机整数

```sql
FLOOR(RAND() * (5 + 1))  -- 包含 0 和 N
```

2. 生成 **1~8** 的随机整数

```sql
FLOOR(1 + RAND() * 8)    -- 包含 1 和 N
```

3. 生成 10~20 的随机整数

```sql
FLOOR(10 + RAND() * (20 - 10 + 1))  -- 包含 A 和 B
```

4.*掷骰子（1~6）**  

```sql
SELECT FLOOR(1 + RAND() * 6) AS dice;
```

5. 随机抽奖（100~999）**  

```sql
SELECT FLOOR(100 + RAND() * 900) AS lucky_number;
```

6.随机布尔值（0/1）**  

```sql
SELECT FLOOR(RAND() * 2) AS coin_flip;
```

7. 生成两位小数的随机数（含 0 和 1）

```sql
SELECT FLOOR(RAND() * 101) / 100;  -- 结果如 0.00, 0.25, ..., 1.00
```

8.生成四位小数的随机数（含 0 和 1）

```sql
SELECT FLOOR(RAND() * 10001) / 10000;  -- 结果如 0.0000, 0.1234, ..., 1.0000
```

## 七、练习:基础题  

1. 计算-25的绝对值  
2. 生成一个 0 到 1 之间的随机小数  
3. 将数字 4.2 向上取整  
4. 将数字 4.9 向下取整  
5. 将数字 3.14159 保留两位小数并四舍五入  
6. 将数字 3.14159 截断为两位小数  
7. 计算 2 的 5 次方  
8. 计算 81 的平方根  
9. 求 17 除以 5 的余数  
10. 查询圆周率 PI 的值  
11. 随机生成一个 1 到 100 之间的整数  
12. 将 -8.7 四舍五入为整数  

## 七、答案:基础题

1. **计算-25的绝对值**

   ```sql
   SELECT ABS(-25);
   ```

2. **生成一个 0 到 1 之间的随机小数：**

   ```sql
   SELECT RAND();
   ```

3. **将数字 4.2 向上取整：**

   ```sql
   SELECT CEIL(4.2);
   ```

4. **将数字 4.9 向下取整：**

   ```sql
   SELECT FLOOR(4.9);
   ```

5. **将数字 3.14159 保留两位小数并四舍五入：**

   ```sql
   SELECT ROUND(3.14159, 2);
   ```

6. **将数字 3.14159 截断为两位小数：**

   ```sql
   SELECT TRUNCATE(3.14159, 2);
   ```

7. **计算 2 的 5 次方：**

   ```sql
   SELECT POW(2, 5);
   ```

8. **计算 81 的平方根：**

   ```sql
   SELECT SQRT(81);
   ```

9. **求 17 除以 5 的余数：**

   ```sql
   SELECT MOD(17, 5);
   ```

10. **查询圆周率 PI 的值：**

```sql
SELECT PI();
```

11. **随机生成一个 1 到 100 之间的整数：**

```sql
SELECT FLOOR(1 + RAND() * 100);
```

12. **将 -8.7 四舍五入为整数：**

```sql
SELECT ROUND(-8.7);
```

------

## 八、练习:中级题  

1. 查询所有记录的绝对值  
2. 按 value 值向上取整，命名为 ceil_value  
3. 查询 value 字段保留 1 位小数后的结果（使用 ROUND）  
4. 按 value 值平方并显示结果  
5. 找出所有平方根为整数的记录  
6. 显示 value 截断为 2 位小数后的结果  
7. 按 value 排序，优先显示绝对值最大者  
8. 求 value 除以 3 的余数（MOD）  
9. 筛选 value 为负数，且其绝对值大于 10 的记录  
10. 每条记录生成一个随机分数（0~100）  

## 八、答案:中级题

假设有一个表 `numbers`，结构如下：

```sql
CREATE TABLE numbers (
  id INT PRIMARY KEY,
  value DECIMAL(10,4)
);
```

1. **查询所有记录的绝对值：**

```sql
SELECT id, value, ABS(value) AS abs_value FROM numbers;
```

2. **按 value 值向上取整，命名为 ceil_value：**

```sql
SELECT id, value, CEIL(value) AS ceil_value FROM numbers;
```

3. **查询 value 字段保留 1 位小数后的结果（使用 ROUND）：**

```sql
SELECT id, ROUND(value, 1) AS rounded_value FROM numbers;
```

4. **按 value 值平方并显示结果：**

```sql
SELECT id, value, POW(value, 2) AS square FROM numbers;
```

5. **找出所有平方根为整数的记录：**

```sql
SELECT id, value FROM numbers
WHERE SQRT(value) = FLOOR(SQRT(value));
```

6. **显示 value 截断为 2 位小数后的结果：**

```sql
SELECT id, TRUNCATE(value, 2) AS truncated FROM numbers;
```

7. **按 value 排序，优先显示绝对值最大者：**

```sql
SELECT id, value FROM numbers ORDER BY ABS(value) DESC;
```

8. **求 value 除以 3 的余数（MOD）：**

```sql
SELECT id, value, MOD(value, 3) AS remainder FROM numbers;
```

9. **筛选 value 为负数，且其绝对值大于 10 的记录：**

```sql
SELECT id, value FROM numbers
WHERE value < 0 AND ABS(value) > 10;
```

10. **每条记录生成一个随机分数（0~100）：**

```sql
SELECT id, FLOOR(RAND() * 101) AS random_score FROM numbers;
```

------

## 九、练习:进阶题  

1. 将 value 截断为 2 位小数，再求平方  
2. 求每条记录的 value 四舍五入为整数后与原值的差值  
3. 按 value 的平方根排序（大到小）  
4. 对表中的 value 字段保留两位小数并乘以圆周率  
5. 选出 value 平方后小于 100 的所有记录  
6. 模拟掷骰子 1~6 的点数（使用 RAND）  
7. 显示 value 的整数部分与小数部分  
8. 找出所有 value 经过四舍五入后仍为偶数的记录

## 九、答案:进阶题

1. **将 value 截断为 2 位小数，再求平方：**

```sql
SELECT id, value, POW(TRUNCATE(value, 2), 2) AS truncated_square FROM numbers;
```

2. **求每条记录的 value 四舍五入为整数后与原值的差值：**

```sql
SELECT id, value, ROUND(value) - value AS round_diff FROM numbers;
```

3. **按 value 的平方根排序（大到小）：**

```sql
SELECT id, value FROM numbers
ORDER BY SQRT(ABS(value)) DESC;
```

4. **对表中的 value 字段保留两位小数并乘以圆周率：**

```sql
SELECT id, ROUND(value, 2) * PI() AS multiplied_pi FROM numbers;
```

5. **选出 value 平方后小于 100 的所有记录：**

```sql
SELECT id, value FROM numbers
WHERE POW(value, 2) < 100;
```

6. **模拟掷骰子 1~6 的点数（使用 RAND）：**

```sql
SELECT FLOOR(1 + RAND() * 6) AS dice_roll;
```

7. **显示 value 的整数部分与小数部分：**

```sql
SELECT id, value,
FLOOR(value) AS int_part,
value - FLOOR(value) AS decimal_part
FROM numbers;
```

8. **找出所有 value 经过四舍五入后仍为偶数的记录：**

```sql
SELECT id, value FROM numbers
WHERE MOD(ROUND(value), 2) = 0;
```

------

如果你需要，我可以把这些题目做成 PDF、Word、或 Markdown 文件方便打印/学习。是否需要打包导出？

## 十、练习:农产品价格表

### 1. 创建农产品价格表

| 类别   | 农产品品种 | 大通农批市场 | 光明农批市场 | 物美超市 | 沃尔玛超市 | 联华超市 | 新发地农批市场 |
| ------ | ---------- | ------------ | ------------ | -------- | ---------- | -------- | -------------- |
| 粮食类 | 稻谷       | 3.50         | 3.65         | 2.65     | 2.89       | 3.90     | 3.58           |
| 粮食类 | 大豆       | 4.80         | 4.70         | 4.40     | 4.20       | 4.50     | 4.75           |
| 粮食类 | 玉米       | 3.00         | 3.00         | 2.70     | 2.30       | 2.50     | 3.00           |
| 蔬菜类 | 黄瓜       | 1.00         | 1.30         | 1.30     | 1.20       | 1.30     | 1.15           |
| 蔬菜类 | 茄子       | 2.20         | 2.00         | 2.48     | 2.28       | 2.35     | 2.10           |
| 蔬菜类 | 卷心菜     | 0.48         | 0.48         | 0.68     | 0.48       | 0.58     | 0.48           |
| 蔬菜类 | 四季豆     | 1.40         | 1.30         | 1.80     | 1.70       | 1.90     | 1.35           |
| 蔬菜类 | 青椒       | 1.00         | 1.00         | 1.50     | 1.50       | 1.50     | 1.00           |
| 蔬菜类 | 豇豆       | 0.65         | 0.65         | 0.80     | 0.75       | 0.80     | 0.65           |
| 蔬菜类 | 芹菜       | 2.70         | 2.80         | 2.80     | 2.80       | 3.00     | 2.75           |
| 蔬菜类 | 西红柿     | 1.80         | 1.80         | 2.30     | 1.90       | 2.00     | 1.80           |
| 蔬菜类 | 韭菜       | 2.20         | 2.30         | 2.20     | 2.50       | 2.50     | 2.25           |
| 蔬菜类 | 香菜       | 2.20         | 2.30         | 2.50     | 2.60       | 2.60     | 2.25           |
| 蔬菜类 | 胡萝卜     | 1.80         | 1.90         | 2.10     | 2.00       | 2.20     | 1.85           |
| 肉蛋类 | 牛肉       | 28.00        | 27.50        | 27.00    | 26.80      | 26.80    | 27.75          |
| 肉蛋类 | 羊肉       | 26.00        | 26.00        | 25.60    | 25.20      | 25.60    | 26.00          |
| 肉蛋类 | 猪肉       | 14.00        | 14.20        | 12.80    | 12.60      | 12.80    | 14.10          |
| 肉蛋类 | 白条鸡     | 7.00         | 7.00         | 6.80     | 6.20       | 6.60     | 7.00           |
| 肉蛋类 | 鸡蛋       | 4.60         | 4.60         | 3.30     | 3.20       | 3.30     | 4.60           |

建表SQL语句

```sql
CREATE TABLE agri_prices (
    id INT AUTO_INCREMENT PRIMARY KEY,
    category VARCHAR(20),
    p_name VARCHAR(50),
    datong DECIMAL(5,2),
    guangming DECIMAL(5,2),
    wumei DECIMAL(5,2),
    walmart DECIMAL(5,2),
    lianhua DECIMAL(5,2),
    xinfadi DECIMAL(5,2)
);
```

### 2.插入价格数据

```sql
INSERT INTO agri_prices (category, p_name, datong, guangming, wumei, walmart, lianhua, xinfadi) VALUES
('粮食类', '稻谷', 3.50, 3.65, 2.65, 2.89, 3.90, 3.58),
('粮食类', '大豆', 4.80, 4.70, 4.40, 4.20, 4.50, 4.75),
('粮食类', '玉米', 3.00, 3.00, 2.70, 2.30, 2.50, 3.00),
('蔬菜类', '黄瓜', 1.00, 1.30, 1.30, 1.20, 1.30, 1.15),
('蔬菜类', '茄子', 2.20, 2.00, 2.48, 2.28, 2.35, 2.10),
('蔬菜类', '卷心菜', 0.48, 0.48, 0.68, 0.48, 0.58, 0.48),
('蔬菜类', '四季豆', 1.40, 1.30, 1.80, 1.70, 1.90, 1.35),
('蔬菜类', '青椒', 1.00, 1.00, 1.50, 1.50, 1.50, 1.00),
('蔬菜类', '豇豆', 0.65, 0.65, 0.80, 0.75, 0.80, 0.65),
('蔬菜类', '芹菜', 2.70, 2.80, 2.80, 2.80, 3.00, 2.75),
('蔬菜类', '西红柿', 1.80, 1.80, 2.30, 1.90, 2.00, 1.80),
('蔬菜类', '韭菜', 2.20, 2.30, 2.20, 2.50, 2.50, 2.25),
('蔬菜类', '香菜', 2.20, 2.30, 2.50, 2.60, 2.60, 2.25),
('蔬菜类', '胡萝卜', 1.80, 1.90, 2.10, 2.00, 2.20, 1.85),
('肉蛋类', '牛肉', 28.00, 27.50, 27.00, 26.80, 26.80, 27.75),
('肉蛋类', '羊肉', 26.00, 26.00, 25.60, 25.20, 25.60, 26.00),
('肉蛋类', '猪肉', 14.00, 14.20, 12.80, 12.60, 12.80, 14.10),
('肉蛋类', '白条鸡', 7.00, 7.00, 6.80, 6.20, 6.60, 7.00),
('肉蛋类', '鸡蛋', 4.60, 4.60, 3.30, 3.20, 3.30, 4.60);
```

### 3.练习题:查询价格表

说明：价格表查询主要练习数学函数。

**基础函数应用**

1. 查询所有蔬菜类商品，显示价格差最大的前3名（用ABS计算物美和沃尔玛价差）
2. 随机显示5条肉蛋类商品，并为每个商品生成0-10的随机整数（RAND结合CEIL）
3. 计算各大市场玉米价格的整数部分（FLOOR）和小数部分
4. 显示所有价格包含.99结尾的商品（TRUNCATE取两位小数后判断）
5. 查询价格波动超过10%的商品（用POW计算方差）
6. 按价格最后一位奇偶分类显示（MOD结合TRUNCATE）

**进阶计算题**

7. 将新发地价格四舍五入到整数后与原始价格对比
8. 计算光明市场价格的平方根（SQRT）并保留两位小数
9. 生成随机排序的粮食类商品列表（RAND）
10. 查询物美价格比沃尔玛高0.5元以上的商品（ABS差值）
11. 显示联华市场价格的小数部分（TRUNCATE）
12. 按价格个位数分组统计商品数量（MOD）
13. 计算大通市场价格的上取整值（CEIL）
14. 找出价格完全相同的市场组合（ROUND比较）
15. 生成带随机折扣系数（0.8-1.0）的价格模拟

**综合应用题**

16. 计算各商品平均价格的整数部分（FLOOR）
17. 查询价格小数部分大于0.5的商品（TRUNCATE）
18. 按价格最后两位数字排序（MOD结合TRUNCATE）
19. 计算各市场价格的三次方（POW）
20. 显示价格与其平方根的差值（SQRT）
21. 生成随机价格波动预测（RAND结合ROUND）
22. 查询价格个位数为偶数的商品（MOD）
23. 计算市场价差绝对值的平方（POW+ABS）
24. 显示价格小数点后两位的截断值（TRUNCATE）
25. 按价格整数部分奇偶性筛选商品

**高级查询题**

26. 计算各商品最高价与最低价差值的绝对值
27. 生成带随机尾数（0-0.99）的价格模拟
28. 查询价格完全整数的商品（TRUNCATE对比）
29. 按价格小数部分四舍五入到十分位
30. 综合应用：生成带随机系数和取整的报价单



### 4.查询价格表答案

1. 查询所有蔬菜类商品，显示价格差最大的前3名（用ABS计算物美和沃尔玛价差）

```sql
SELECT product, ABS(wu_mei - wal_mart) AS price_diff 
FROM produce_prices 
WHERE category = '蔬菜类'
ORDER BY price_diff DESC 
LIMIT 3;
```

2. 随机显示5条肉蛋类商品，并为每个商品生成0-10的随机整数（RAND结合CEIL）

```sql
SELECT product, CEIL(RAND()*10) AS random_num 
FROM produce_prices 
WHERE category = '肉蛋类'
ORDER BY RAND() 
LIMIT 5;
```

3. 计算各大市场玉米价格的整数部分（FLOOR）和小数部分

```sql
SELECT 
    FLOOR(da_tong) AS da_tong_int,
    da_tong - FLOOR(da_tong) AS da_tong_decimal,
    ...其他市场同样处理...
FROM produce_prices 
WHERE product = '玉米';
```

4. 显示所有价格包含.99结尾的商品（TRUNCATE取两位小数后判断）

```sql
SELECT product 
FROM produce_prices 
WHERE TRUNCATE(da_tong,2) - TRUNCATE(da_tong,1) = 0.09 
   OR ...其他市场同样判断...;
```

5. 查询价格波动超过10%的商品（用POW计算方差）

```sql
SELECT product,
       POW(MAX(da_tong) - MIN(da_tong), 2) AS variance
FROM produce_prices
GROUP BY product
HAVING variance > 0.1;
```

6. 按价格最后一位奇偶分类显示（MOD结合TRUNCATE）

```sql
SELECT product,
       CASE MOD(TRUNCATE(da_tong*10,0),2)
           WHEN 0 THEN '偶' ELSE '奇' END AS parity
FROM produce_prices;
```

**7. 将新发地价格四舍五入到整数后与原始价格对比**

```sql
SELECT product, 
       xin_fa_di AS original_price,
       ROUND(xin_fa_di, 0) AS rounded_price
FROM produce_prices;
```

解析：使用ROUND(数值,0)实现整数四舍五入

**8. 计算光明市场价格的平方根并保留两位小数**

```sql
SELECT product,
       guang_ming,
       ROUND(SQRT(guang_ming), 2) AS sqrt_price
FROM produce_prices;
```

注意：仅计算正数平方根，价格字段需保证非负

**9. 生成随机排序的粮食类商品列表**

```sql
SELECT product 
FROM produce_prices
WHERE category = '粮食类'
ORDER BY RAND();
```

原理：RAND()为每条记录生成随机排序因子

**10. 查询物美价格比沃尔玛高0.5元以上的商品**

```sql
SELECT product, wu_mei, wal_mart
FROM produce_prices
WHERE wu_mei - wal_mart > 0.5;
```

**11. 显示联华市场价格的小数部分**

```sql
SELECT product,
       lian_hua,
       lian_hua - TRUNCATE(lian_hua, 0) AS decimal_part
FROM produce_prices;
```

技巧：用原值减整数部分获取纯小数

**12. 按价格个位数分组统计商品数量**

```sql
SELECT 
    MOD(TRUNCATE(lian_hua, 0), 10) AS units_digit,
    COUNT(*) AS product_count
FROM produce_prices
GROUP BY units_digit;
```

**13. 计算大通市场价格的上取整值**

```sql
SELECT product,
       da_tong,
       CEIL(da_tong) AS ceil_price
FROM produce_prices;
```

**14. 找出价格完全相同的市场组合**

```sql
SELECT product,
       CONCAT_WS('=', 
           ROUND(da_tong,2), 
           ROUND(guang_ming,2),
           ...其他市场...
       ) AS same_prices
FROM produce_prices
WHERE ROUND(da_tong,2) = ROUND(guang_ming,2)
   OR ROUND(da_tong,2) = ROUND(wu_mei,2)
   ...其他组合比较...;
```

关键点：使用ROUND消除小数精度差异

**15. 生成带随机折扣系数（0.8-1.0）的价格模拟**

```sql
SELECT product,
       da_tong * (0.8 + RAND()*0.2) AS discount_da_tong,
       ROUND(guang_ming * (0.8 + RAND()*0.2), 2) AS discount_guang_ming
FROM produce_prices;
```

公式：RAND()*0.2生成0-0.2的随机增量

**16. 计算各商品平均价格的整数部分**

```sql
SELECT product,
       FLOOR(AVG(da_tong + guang_ming + wu_mei + wal_mart + lian_hua + xin_fa_di)/6) AS avg_int
FROM produce_prices
GROUP BY product;
```

**17. 查询价格小数部分大于0.5的商品**

```sql
SELECT product, da_tong
FROM produce_prices
WHERE da_tong - TRUNCATE(da_tong, 0) > 0.5;
```

**18. 按价格最后两位数字排序（大通市场为例）**

```sql
SELECT product, da_tong,
       MOD(TRUNCATE(da_tong*100,0),100) AS last_two_digits
FROM produce_prices
ORDER BY last_two_digits DESC;
```

 技巧：da_tong*100将小数点后两位转为整数，MOD取最后两位

**19. 计算各市场价格的三次方（光明市场示例）**

```sql
SELECT product, guang_ming,
       POW(guang_ming, 3) AS cubed_price
FROM produce_prices;
```

**20. 显示价格与其平方根的差值（沃尔玛示例）**

```sql
SELECT product, wal_mart,
       wal_mart - ROUND(SQRT(wal_mart),2) AS diff_sqrt
FROM produce_prices;
```

**21. 生成±10%随机波动预测（联华市场示例）**

```sql
SELECT product, lian_hua,
       ROUND(lian_hua * (0.9 + RAND()*0.2), 2) AS simulated_price
FROM produce_prices;
```

**22. 查询价格个位数为偶数的商品（新发地市场）**

```sql
SELECT product, xin_fa_di
FROM produce_prices
WHERE MOD(TRUNCATE(xin_fa_di,0), 2) = 0;
```

**23. 计算大通与光明价差绝对值的平方**

```sql
SELECT product,
       POW(ABS(da_tong - guang_ming), 2) AS squared_diff
FROM produce_prices;
```

**24. 显示价格小数点后两位的截断值（物美超市）**

```sql
SELECT product, 
       TRUNCATE(wu_mei, 2) AS truncated_price
FROM produce_prices;
```

**25. 筛选整数部分为奇数的商品（沃尔玛）**

```sql
SELECT product, wal_mart
FROM produce_prices
WHERE MOD(TRUNCATE(wal_mart,0), 2) = 1;
```

**26. 计算最高最低价差绝对值**

```sql
SELECT product,
       ABS(GREATEST(da_tong, guang_ming, wu_mei, wal_mart, lian_hua, xin_fa_di) -
       LEAST(da_tong, guang_ming, wu_mei, wal_mart, lian_hua, xin_fa_di)) AS price_range
FROM produce_prices;
```

**27. 生成带随机尾数的价格（大通市场）**

```sql
SELECT product,
       TRUNCATE(da_tong,0) + ROUND(RAND(), 2) AS random_tail_price
FROM produce_prices;
```

**28. 查询价格完全整数的商品（联华超市）**

```sql
SELECT product, lian_hua
FROM produce_prices
WHERE lian_hua = TRUNCATE(lian_hua, 0);
```

**29. 四舍五入到十分位（光明市场）**

```sql
SELECT product,
       ROUND(guang_ming, 1) AS tenth_rounded
FROM produce_prices;
```

**30. 综合报价单（含随机折扣和取整）**

```sql
SELECT product,
       CEIL(da_tong * (0.8 + RAND()*0.2)) AS quote_da_tong,
       FLOOR(guang_ming * (0.9 + RAND()*0.1)) AS quote_guang_ming,
       ROUND(wu_mei * (0.85 + RAND()*0.15), 1) AS quote_wu_mei
FROM produce_prices;
```

# 5月20日：if函数

MySQL 中的 `IF` 函数是一个逻辑控制函数，用于根据条件判断返回不同的结果。它类似于编程语言中的三元运算符（`条件 ? 结果1 : 结果2`），语法简洁，适用于简单的条件分支逻辑。

---

## 语法

```sql
IF(condition, value_if_true, value_if_false)
```

- **`condition`**：需要判断的条件表达式（必须返回布尔值 `TRUE`/`FALSE`）。
- **`value_if_true`**：当条件为真时返回的值。
- **`value_if_false`**：当条件为假时返回的值。

---

## 用法1:数值判断(双分支)

```sql
SELECT IF(10 > 5, 'Yes', 'No');  -- 输出: 'Yes'
SELECT IF(10 < 5, 'Yes', 'No');  -- 输出: 'No'
```


## 用法2.IF函数嵌套(多分支)

处理多重条件分支：

```sql
SELECT 
    name,
    score,
    IF(score >= 90, 'A',
        IF(score >= 80, 'B',
            IF(score >= 70, 'C',
                IF(score >= 60, 'D', 'F')
            )
        )
    ) AS grade
FROM students;
```

输出结果：

```
+---------+-------+-------+
| name    | score | grade |
+---------+-------+-------+
| Alice   | 85    | B     |
| Bob     | 72    | C     |
| Charlie | 60    | D     |
| David   | 45    | F     |
+---------+-------+-------+
```

## 用法3:结合聚合函数

动态统计符合条件的数据：

```sql
SELECT 
    COUNT(*) AS total_students,
    SUM(IF(score >= 60, 1, 0)) AS passed_count,
    SUM(IF(score < 60, 1, 0)) AS failed_count
FROM students;
```

输出结果：

```
+----------------+--------------+--------------+
| total_students | passed_count | failed_count |
+----------------+--------------+--------------+
| 4              | 3            | 1            |
+----------------+--------------+--------------+
```

---

## **注意事项**

1. **返回值类型兼容性**  
   `IF` 函数返回的 `value_if_true` 和 `value_if_false` 需为同一数据类型，否则 MySQL 会隐式转换类型：

   ```sql
   SELECT IF(TRUE, 100, 'Fail');  -- 输出: 100（字符串 'Fail' 被转为数值 0）
   ```

2. **处理 NULL 值**  
   如果条件中涉及 `NULL`，需用 `IS NULL` 或 `IS NOT NULL` 判断：

   ```sql
   SELECT IF(NULL, 'True', 'False');  -- 输出: 'False'（NULL 视为假）
   SELECT IF(column IS NULL, 'Unknown', column) FROM table;
   ```

3. **替代方案：CASE 语句**  
   对于复杂多条件分支，推荐使用 `CASE` 语句（更易读）：

   ```sql
   SELECT 
       name,
       CASE 
           WHEN score >= 90 THEN 'A'
           WHEN score >= 80 THEN 'B'
           WHEN score >= 70 THEN 'C'
           ELSE 'F'
       END AS grade
   FROM students;
   ```

---

## **典型应用场景**

1. **动态列生成**  
   根据条件生成标记列（如是否达标、状态分类）。
2. **数据清洗**  
   替换无效值或格式化字段。
3. **聚合统计**  
   按条件分组计数或求和。
4. **查询结果优化**  
   简化复杂逻辑的查询结果展示。

---

### 总结

`IF` 函数是 MySQL 中处理简单条件分支的高效工具，适合快速实现二元逻辑。但在多层嵌套或复杂条件时，建议改用 `CASE` 语句以提高代码可读性。

### 练习1：判断是否及格

假设有一张 `students` 表：

```sql
CREATE TABLE students (
    id INT,
    name VARCHAR(50),
    score INT
);
```

插入示例数据：

```sql
INSERT INTO students VALUES
(1, 'Alice', 85),
(2, 'Bob', 72),
(3, 'Charlie', 60),
(4, 'David', 45);
```

**示例：标记成绩是否及格**

```sql
SELECT 
    name, 
    score,
    IF(score >= 60, 'Pass', 'Fail') AS result
FROM students;
```

输出结果：

```
+---------+-------+--------+
| name    | score | result |
+---------+-------+--------+
| Alice   | 85    | Pass   |
| Bob     | 72    | Pass   |
| Charlie | 60    | Pass   |
| David   | 45    | Fail   |
+---------+-------+--------+
```



## ifnull()函数



## 外键

以下是 5 道 MySQL 外键操作的综合练习题，涵盖外键的创建、删除和增删改查操作：

---

### **题目 1：基础外键创建**

**场景**  
创建两张表 `departments` 和 `employees`，满足以下要求：  

1. `departments` 表字段：`dept_id`(主键)、`dept_name`  
2. `employees` 表字段：`emp_id`(主键)、`emp_name`, `dept_id`（外键关联 departments 表的 dept_id）  
3. 当部门被删除时，自动将员工表中对应部门的 `dept_id` 设为 `NULL`。

**参考答案**

```sql
-- 创建 departments 表
CREATE TABLE departments (
    dept_id INT PRIMARY KEY,
    dept_name VARCHAR(50)
ENGINE=InnoDB;

-- 创建 employees 表（带外键）
CREATE TABLE employees (
    emp_id INT PRIMARY KEY,
    emp_name VARCHAR(50),
    dept_id INT,
    FOREIGN KEY (dept_id)
        REFERENCES departments(dept_id)
        ON DELETE SET NULL
) ENGINE=InnoDB;
```

---

### **题目 2：级联删除操作**

**场景**  
在 `orders` 和 `order_items` 表中：  

1. 删除订单时，自动删除关联的所有订单项  
2. 更新订单号时，自动同步更新订单项中的订单号  
3. 写出创建表的 SQL 语句。

**参考答案**

```sql
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    customer_name VARCHAR(50)
) ENGINE=InnoDB;

CREATE TABLE order_items (
    item_id INT PRIMARY KEY,
    order_id INT,
    product_name VARCHAR(50),
    FOREIGN KEY (order_id)
        REFERENCES orders(order_id)
        ON DELETE CASCADE
        ON UPDATE CASCADE
) ENGINE=InnoDB;
```

---

### **题目 3：外键冲突处理**

**场景**  
向 `employees` 表插入以下数据，观察结果并解释原因：  

```sql
INSERT INTO departments (dept_id, dept_name) VALUES (1, 'IT');

-- 尝试插入员工数据：
INSERT INTO employees (emp_id, emp_name, dept_id)
VALUES (101, 'Alice', 2);  -- dept_id=2 不存在于 departments 表
```

**参考答案**  
插入失败，报错 `ERROR 1452 (23000): Cannot add or update a child row: a foreign key constraint fails`。  
**原因**：外键约束要求 `employees.dept_id` 必须存在于 `departments.dept_id` 中。

---

### **题目 4：联表查询与删除**

**场景**  
查询 `IT` 部门的所有员工，并删除 `IT` 部门（观察员工表的变化）。

**参考答案**

```sql
-- 联表查询
SELECT e.emp_id, e.emp_name
FROM employees e
JOIN departments d ON e.dept_id = d.dept_id
WHERE d.dept_name = 'IT';

-- 删除部门（级联设为 SET NULL 时的行为）
DELETE FROM departments WHERE dept_name = 'IT';

-- 验证员工表
SELECT * FROM employees;  -- IT 部门员工的 dept_id 变为 NULL
```

---

### **题目 5：修改外键约束**

**场景**  
将 `employees` 表的外键约束从 `ON DELETE SET NULL` 改为 `ON DELETE RESTRICT`，并验证效果。

**参考答案**

```sql
-- 1. 删除原有外键
ALTER TABLE employees
DROP FOREIGN KEY employees_ibfk_1;  -- 外键名称通过 SHOW CREATE TABLE 查询

-- 2. 添加新约束
ALTER TABLE employees
ADD FOREIGN KEY (dept_id)
    REFERENCES departments(dept_id)
    ON DELETE RESTRICT;

-- 3. 验证约束
-- 尝试删除有员工的部门
DELETE FROM departments WHERE dept_id = 1;  -- 报错：无法删除被引用的父表记录
```

---

### **总结**

通过以上练习可掌握：  

1. 外键的创建与级联行为配置  
2. 外键约束对增删改操作的影响  
3. 联表查询与约束冲突处理  
4. 动态修改外键约束的方法

## 5月21日:外键



## 5月22日:on的用法



## 5月23日 join的用法



## 5月24日：详解表结构

以下是 MySQL 定义数据表的完整语法和详细说明，适合初学者入门：

---

## **MySQL 定义表的基本语法**

```sql
CREATE TABLE [IF NOT EXISTS] 表名 (
    -- 列定义
    列1 数据类型 [列约束],
    列2 数据类型 [列约束],
    
    -- 表级约束
    [PRIMARY KEY (列名)],
    [FOREIGN KEY (外键列) REFERENCES 父表(父表列)],
    [UNIQUE (列名)],
    [CHECK (条件表达式)]
)
[ENGINE=存储引擎]
[DEFAULT CHARSET=字符集]
[COMMENT='表注释']
[其他表选项];
```

---

## CREATE TABLE 

## [IF NOT EXISTS]

用途

在 MySQL 中，IF NOT EXISTS 是用于创建表时避免重复创建的关键字。

作用

- 存在性检查：当表已存在时，跳过创建而不是报错。
- 防冲突：避免因重复执行建表语句导致程序中断。
- 脚本健壮性：确保 SQL 脚本可重复执行而无需手动检查表是否存在。

1. 不使用 IF NOT EXISTS

```sql
CREATE TABLE IF NOT EXISTS students (
    id INT PRIMARY KEY,
    name VARCHAR(50)
);
```

如果表已存在：报错 ERROR 1050 (42S01): Table 'students' already exists。

2. 使用 IF NOT EXISTS

```sql
CREATE TABLE IF NOT EXISTS students (
    id INT PRIMARY KEY,
    name VARCHAR(50)
);
```

如果表已存在：显示警告 Query OK, 0 rows affected, 1 warning，但不会报错。

执行后可通过 SHOW WARNINGS 查看提示信息：

```sql
SHOW WARNINGS;
```

输出

```sql
+-------+------+----------------------------------------------+
| Level | Code | Message                                      |
+-------+------+----------------------------------------------+
| Note  | 1050 | Table 'students' already exists              |
+-------+------+----------------------------------------------+
```

## 表名

## 列定义

**示例**：

```sql
CREATE TABLE users (
    id INT PRIMARY KEY AUTO_INCREMENT,  -- 主键，自增
    username VARCHAR(50) NOT NULL,      -- 非空
    email VARCHAR(100) UNIQUE,          -- 唯一值
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP  -- 默认值
);
```

### 列名

用途：自定义的字段名称（如 `id`, `name`）。

### 数据类型

用途：指定列存储的数据类型（如 INT, VARCHAR, DATE）。

常用数据类型**

| **类型**       | **用途**                   | **示例**               |
| -------------- | -------------------------- | ---------------------- |
| `INT`          | 整数（如用户ID）           | `age INT`              |
| `VARCHAR(n)`   | 可变长度字符串（如用户名） | `username VARCHAR(50)` |
| `DECIMAL(m,n)` | 精确小数（如金额）         | `price DECIMAL(10,2)`  |
| `DATE`         | 日期（如生日）             | `birthday DATE`        |
| `TIMESTAMP`    | 时间戳（如创建时间）       | `created_at TIMESTAMP` |
| `TEXT`         | 长文本（如文章内容）       | `content TEXT`         |


### 列约束

用途：可选，限制列的取值（如 `NOT NULL`, `AUTO_INCREMENT`）。

| **约束**         | **说明**             | **示例**                                     |
| ---------------- | -------------------- | -------------------------------------------- |
| `PRIMARY KEY`    | 主键（唯一标识行）   | `id INT PRIMARY KEY`                         |
| `AUTO_INCREMENT` | 自增（通常用于主键） | `id INT AUTO_INCREMENT`                      |
| `NOT NULL`       | 禁止为空             | `username VARCHAR(50) NOT NULL`              |
| `UNIQUE`         | 值唯一               | `email VARCHAR(100) UNIQUE`                  |
| `DEFAULT`        | 默认值               | `status INT DEFAULT 1`                       |
| `FOREIGN KEY`    | 外键（关联其他表）   | `FOREIGN KEY (user_id) REFERENCES users(id)` |


- NOT NULL：禁止空值。
- DEFAULT 默认值：设置默认值。
- AUTO_INCREMENT：自增（仅限整数类型）。
- UNIQUE：唯一值约束。
- COMMENT '注释'：列注释。

```sql
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL UNIQUE,
    age TINYINT UNSIGNED DEFAULT 18,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

## 表约束

### PRIMARY KEY

主键约束

```sql
PRIMARY KEY (列1, 列2)（支持复合主键）。
```

### FOREIGN KEY

外键约束：

```sql
FOREIGN KEY (外键列) 
    REFERENCES 父表(父表列)
    [ON DELETE 行为] 
    [ON UPDATE 行为]
```

### 行为选项

- CASCADE
- SET NULL
- RESTRICT（默认）

### 唯一约束：

```sql
UNIQUE (列1, 列2)。
```

### 检查约束：

```sql
CHECK (条件)（MySQL 8.0.16+ 支持强制检查）。

```

## 表选项

| **选项**          | **说明**   | **常用值**                   |
| ----------------- | ---------- | ---------------------------- |
| `ENGINE`          | 存储引擎   | `InnoDB`（推荐）, `MyISAM`   |
| `DEFAULT CHARSET` | 默认字符集 | `utf8mb4`（支持中文和Emoji） |
| `COMMENT`         | 表注释     | `COMMENT='用户表'`           |

### [ENGINE=存储引擎]

- ENGINE=InnoDB（默认）
- ENGINE=MyISAM

### [DEFAULT CHARSET=字符集] 

建议显式指定，避免依赖服务器默认配置：

```SQL
CREATE TABLE IF NOT EXISTS users (
    id INT PRIMARY KEY
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```


### [COMMENT='表注释'];

```sql
COMMENT='用户表'。
```

### AUTO_INCREMENT

```sql
AUTO_INCREMENT=100（设置自增起始值）
```

### ROW_FORMAT

```sql
ROW_FORMAT=COMPRESSED（行格式）。
```

### 示例

```sql
CREATE TABLE logs (
    log_id INT AUTO_INCREMENT PRIMARY KEY,
    content TEXT
) ENGINE=InnoDB 
  DEFAULT CHARSET=utf8mb4 
  COMMENT='系统日志表'
  AUTO_INCREMENT=1000;
```

---

## 示例

**示例**：

```sql
CREATE TABLE orders (
    order_id INT,
    user_id INT,
    product_id INT,
    -- 表级约束
    PRIMARY KEY (order_id, user_id),  -- 复合主键
    FOREIGN KEY (user_id) REFERENCES users(id),
    UNIQUE (order_id, product_id)
);
```

**完整示例**：

```sql
CREATE TABLE products (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100) NOT NULL,
    price DECIMAL(10,2) DEFAULT 0.00
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='商品表';
```

---

**实际案例：用户表 + 订单表**

```sql
-- 用户表
CREATE TABLE users (
    id INT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) NOT NULL UNIQUE,
    email VARCHAR(100) NOT NULL UNIQUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- 订单表（关联用户表）
CREATE TABLE orders (
    order_id INT PRIMARY KEY AUTO_INCREMENT,
    user_id INT NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    order_date DATE,
    FOREIGN KEY (user_id) REFERENCES users(id)
) ENGINE=InnoDB;
```

---

## **注意事项**

1. **主键必须唯一且非空**：每个表只能有一个主键。
2. **外键要求**：父表的被引用列必须是主键或唯一索引。
3. **存储引擎选择**：推荐使用 `InnoDB`（支持事务和外键）。
4. **字符集推荐**：使用 `utf8mb4`（兼容所有Unicode字符，包括Emoji）。
5. **命名规范**：表名和列名建议用英文小写和下划线（如 `user_profile`）。

---

## **常见错误**

- **忘记逗号**：列定义之间必须用逗号分隔。
- **数据类型错误**：如用 `VARCHAR` 存数字。
- **重复主键**：插入重复的主键值会报错。
- **外键约束失败**：插入不存在的父表数据会报错。



